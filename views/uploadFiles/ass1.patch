diff --git a/BUGS b/BUGS
new file mode 100644
index 0000000..81d2220
--- /dev/null
+++ b/BUGS
@@ -0,0 +1,7 @@
+formatting:
+	need to fix PAGEBREAK mechanism
+
+sh:
+	can't always runcmd in child -- breaks cd.
+	maybe should hard-code PATH=/ ?
+
diff --git a/Makefile b/Makefile
index c94c71d..a072d21 100644
--- a/Makefile
+++ b/Makefile
@@ -27,6 +27,9 @@ OBJS = \
 	uart.o\
 	vectors.o\
 	vm.o\
+	implicit_return.o\
+	linkedList.o\
+	
 
 # Cross-compiling (e.g., on Mac OS X)
 # TOOLPREFIX = i386-jos-elf
@@ -53,6 +56,10 @@ endif
 # If the makefile can't find QEMU, specify its path here
 # QEMU = qemu-system-i386
 
+ifndef SCHEDFLAG
+	SCHEDFLAG=DEFAULT
+endif
+
 # Try to infer the correct QEMU
 ifndef QEMU
 QEMU = $(shell if which qemu > /dev/null; \
@@ -75,8 +82,8 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+CFLAGS = -nostdinc -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector) -D $(SCHEDFLAG)=1
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
@@ -97,7 +104,7 @@ bootblock: bootasm.S bootmain.c
 	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
 	$(OBJDUMP) -S bootblock.o > bootblock.asm
 	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
-	perl sign.pl bootblock
+	./sign.pl bootblock
 
 entryother: entryother.S
 	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
@@ -169,9 +176,10 @@ UPROGS=\
 	_rm\
 	_sh\
 	_stressfs\
-	_usertests\
 	_wc\
 	_zombie\
+	_read\
+	_sanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -179,14 +187,30 @@ fs.img: mkfs README $(UPROGS)
 -include *.d
 
 clean: 
+	
+
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
 	.gdbinit \
-	$(UPROGS)
+	$(UPROGS) \
+
+# make a printout
+FILES = $(shell grep -v '^\#' runoff.list)
+PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+
+xv6.pdf: $(PRINT)
+	./runoff
+	ls -l xv6.pdf
+
+print: xv6.pdf
 
 # run in emulators
 
+bochs : fs.img xv6.img
+	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
+	bochs -q
+
 # try to generate a unique GDB port
 GDBPORT = $(shell expr `id -u` % 5000 + 25000)
 # QEMU's gdb stub command line changed in 0.11
@@ -194,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 1
+CPUS := 2
 endif
 QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
@@ -217,3 +241,47 @@ qemu-gdb: fs.img xv6.img .gdbinit
 qemu-nox-gdb: fs.img xv6.img .gdbinit
 	@echo "*** Now run 'gdb'." 1>&2
 	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
+
+# CUT HERE
+# prepare dist for students
+# after running make dist, probably want to
+# rename it to rev0 or rev1 or so on and then
+# check in that version.
+
+EXTRA=\
+	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c read.c sanity.c wc.c zombie.c\
+	printf.c umalloc.c\
+	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+	.gdbinit.tmpl gdbutil\
+
+dist:
+	rm -rf dist
+	mkdir dist
+	for i in $(FILES); \
+	do \
+		grep -v PAGEBREAK $$i >dist/$$i; \
+	done
+	sed '/CUT HERE/,$$d' Makefile >dist/Makefile
+	echo >dist/runoff.spec
+	cp $(EXTRA) dist
+
+dist-test:
+	rm -rf dist
+	make dist
+	rm -rf dist-test
+	mkdir dist-test
+	cp dist/* dist-test
+	cd dist-test; $(MAKE) print
+	cd dist-test; $(MAKE) bochs || true
+	cd dist-test; $(MAKE) qemu
+
+# update this rule (change rev#) when it is time to
+# make a new revision.
+tar:
+	rm -rf /tmp/xv6
+	mkdir -p /tmp/xv6
+	cp dist/* dist/.gdbinit.tmpl /tmp/xv6
+	(cd /tmp; tar cf - xv6) | gzip >xv6-rev5.tar.gz
+
+.PHONY: dist-test dist
diff --git a/Notes b/Notes
new file mode 100644
index 0000000..74c8aea
--- /dev/null
+++ b/Notes
@@ -0,0 +1,123 @@
+bochs 2.2.6:
+./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
+bochs CVS after 2.2.6:
+./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
+
+bootmain.c doesn't work right if the ELF sections aren't
+sector-aligned. so you can't use ld -N. and the sections may also need
+to be non-zero length, only really matters for tiny "kernels".
+
+kernel loaded at 1 megabyte. stack same place that bootasm.S left it.
+
+kinit() should find real mem size
+  and rescue useable memory below 1 meg
+
+no paging, no use of page table hardware, just segments
+
+no user area: no magic kernel stack mapping
+  so no copying of kernel stack during fork
+  though there is a kernel stack page for each process
+
+no kernel malloc(), just kalloc() for user core
+
+user pointers aren't valid in the kernel
+
+are interrupts turned on in the kernel? yes.
+
+pass curproc explicitly, or implicit from cpu #?
+  e.g. argument to newproc()?
+  hmm, you need a global curproc[cpu] for trap() &c
+
+no stack expansion
+
+test running out of memory, process slots
+
+we can't really use a separate stack segment, since stack addresses
+need to work correctly as ordinary pointers. the same may be true of
+data vs text. how can we have a gap between data and stack, so that
+both can grow, without committing 4GB of physical memory? does this
+mean we need paging?
+
+perhaps have fixed-size stack, put it in the data segment?
+
+oops, if kernel stack is in contiguous user phys mem, then moving
+users' memory (e.g. to expand it) will wreck any pointers into the
+kernel stack.
+
+do we need to set fs and gs? so user processes can't abuse them?
+
+setupsegs() may modify current segment table, is that legal?
+
+trap() ought to lgdt on return, since currently only done in swtch()
+
+protect hardware interrupt vectors from user INT instructions?
+
+test out-of-fd cases for creating pipe.
+test pipe reader closes then write
+test two readers, two writers.
+test children being inherited by grandparent &c
+
+some sleep()s should be interruptible by kill()
+
+locks
+  init_lock
+    sequences CPU startup
+  proc_table_lock
+    also protects next_pid
+  per-fd lock *just* protects count read-modify-write
+    also maybe freeness?
+  memory allocator
+  printf
+
+in general, the table locks protect both free-ness and
+  public variables of table elements
+  in many cases you can use table elements w/o a lock
+  e.g. if you are the process, or you are using an fd
+
+lock order
+  per-pipe lock
+  proc_table_lock fd_table_lock kalloc_lock
+  console_lock
+
+do you have to be holding the mutex in order to call wakeup()? yes
+
+device interrupts don't clear FL_IF
+  so a recursive timer interrupt is possible
+
+what does inode->busy mean?
+  might be held across disk reads
+  no-one is allowed to do anything to the inode
+  protected by inode_table_lock
+inode->count counts in-memory pointers to the struct
+  prevents inode[] element from being re-used
+  protected by inode_table_lock
+
+blocks and inodes have ad-hoc sleep-locks
+  provide a single mechanism?
+
+kalloc() can return 0; do callers handle this right?
+
+test: one process unlinks a file while another links to it
+test: one process opens a file while another deletes it
+test: deadlock d/.. vs ../d, two processes.
+test: dup() shared fd->off
+test: does echo foo > x truncate x?
+
+sh: ioredirection incorrect now we have pipes
+sh: chain of pipes won't work, also ugly that parent closes fdarray entries too
+sh: dynamic memory allocation?
+sh: should sh support ; () &
+sh: stop stdin on ctrl-d (for cat > y)
+
+really should have bdwrite() for file content
+  and make some inode updates async
+  so soft updates make sense
+
+disk scheduling
+echo foo > bar should truncate bar
+  so O_CREATE should not truncate
+  but O_TRUNC should
+
+make it work on a real machine
+release before acquire at end of sleep?
+check 2nd disk (i.e. if not in .bochsrc)
diff --git a/TRICKS b/TRICKS
new file mode 100644
index 0000000..8d1439f
--- /dev/null
+++ b/TRICKS
@@ -0,0 +1,140 @@
+This file lists subtle things that might not be commented 
+as well as they should be in the source code and that
+might be worth pointing out in a longer explanation or in class.
+
+---
+
+[2009/07/12: No longer relevant; forkret1 changed
+and this is now cleaner.]
+
+forkret1 in trapasm.S is called with a tf argument.
+In order to use it, forkret1 copies the tf pointer into
+%esp and then jumps to trapret, which pops the 
+register state out of the trap frame.  If an interrupt
+came in between the mov tf, %esp and the iret that
+goes back out to user space, the interrupt stack frame
+would end up scribbling over the tf and whatever memory
+lay under it.
+
+Why is this safe?  Because forkret1 is only called
+the first time a process returns to user space, and
+at that point, cp->tf is set to point to a trap frame
+constructed at the top of cp's kernel stack.  So tf 
+*is* a valid %esp that can hold interrupt state.
+
+If other tf's were used in forkret1, we could add
+a cli before the mov tf, %esp.
+
+---
+
+In pushcli, must cli() no matter what.  It is not safe to do
+
+  if(cpus[cpu()].ncli == 0)
+    cli();
+  cpus[cpu()].ncli++;
+
+because if interrupts are off then we might call cpu(), get
+rescheduled to a different cpu, look at cpus[oldcpu].ncli,
+and wrongly decide not to disable interrupts on the new cpu.
+
+Instead do 
+
+  cli();
+  cpus[cpu()].ncli++;
+
+always.
+
+---
+
+There is a (harmless) race in pushcli, which does
+
+	eflags = readeflags();
+	cli();
+	if(c->ncli++ == 0)
+		c->intena = eflags & FL_IF;
+
+Consider a bottom-level pushcli.  
+If interrupts are disabled already, then the right thing
+happens: read_eflags finds that FL_IF is not set,
+and intena = 0.  If interrupts are enabled, then
+it is less clear that the right thing happens:
+the readeflags can execute, then the process
+can get preempted and rescheduled on another cpu,
+and then once it starts running, perhaps with 
+interrupts disabled (can happen since the scheduler
+only enables interrupts once per scheduling loop,
+not every time it schedules a process), it will 
+incorrectly record that interrupts *were* enabled.
+This doesn't matter, because if it was safe to be
+running with interrupts enabled before the context
+switch, it is still safe (and arguably more correct)
+to run with them enabled after the context switch too.
+
+In fact it would be safe if scheduler always set
+	c->intena = 1;
+before calling swtch, and perhaps it should.
+
+---
+
+The x86's processor-ordering memory model 
+matches spin locks well, so no explicit memory
+synchronization instructions are required in
+acquire and release.  
+
+Consider two sequences of code on different CPUs:
+
+CPU0
+A;
+release(lk);
+
+and
+
+CPU1
+acquire(lk);
+B;
+
+We want to make sure that:
+  - all reads in B see the effects of writes in A.
+  - all reads in A do *not* see the effects of writes in B.
+ 
+The x86 guarantees that writes in A will go out
+to memory before the write of lk->locked = 0 in 
+release(lk).  It further guarantees that CPU1 
+will observe CPU0's write of lk->locked = 0 only
+after observing the earlier writes by CPU0.
+So any reads in B are guaranteed to observe the
+effects of writes in A.
+
+According to the Intel manual behavior spec, the
+second condition requires a serialization instruction
+in release, to avoid reads in A happening after giving
+up lk.  No Intel SMP processor in existence actually
+moves reads down after writes, but the language in
+the spec allows it.  There is no telling whether future
+processors will need it.
+
+---
+
+The code in fork needs to read np->pid before
+setting np->state to RUNNABLE.  The following
+is not a correct way to do this:
+
+	int
+	fork(void)
+	{
+	  ...
+	  np->state = RUNNABLE;
+	  return np->pid; // oops
+	}
+
+After setting np->state to RUNNABLE, some other CPU
+might run the process, it might exit, and then it might
+get reused for a different process (with a new pid), all
+before the return statement.  So it's not safe to just
+"return np->pid". Even saving a copy of np->pid before
+setting np->state isn't safe, since the compiler is
+allowed to re-order statements.
+
+The real code saves a copy of np->pid, then acquires a lock
+around the write to np->state. The acquire() prevents the
+compiler from re-ordering.
diff --git a/cat.c b/cat.c
index 2b2dcc7..f415c7e 100644
--- a/cat.c
+++ b/cat.c
@@ -13,7 +13,7 @@ cat(int fd)
     write(1, buf, n);
   if(n < 0){
     printf(1, "cat: read error\n");
-    exit();
+    exit(EXIT_STATUS_FAILURE);
   }
 }
 
@@ -24,16 +24,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     cat(0);
-    exit();
+    exit(EXIT_STATUS_FAILURE);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_FAILURE);
     }
     cat(fd);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_SUCCESS);
 }
diff --git a/cuth b/cuth
new file mode 100755
index 0000000..cce8c0c
--- /dev/null
+++ b/cuth
@@ -0,0 +1,48 @@
+#!/usr/bin/perl
+
+$| = 1;
+
+sub writefile($@){
+	my ($file, @lines) = @_;
+	
+	sleep(1);
+	open(F, ">$file") || die "open >$file: $!";
+	print F @lines;
+	close(F);
+}
+
+# Cut out #include lines that don't contribute anything.
+for($i=0; $i<@ARGV; $i++){
+	$file = $ARGV[$i];
+	if(!open(F, $file)){
+		print STDERR "open $file: $!\n";
+		next;
+	}
+	@lines = <F>;
+	close(F);
+	
+	$obj = "$file.o";
+	$obj =~ s/\.c\.o$/.o/;
+	system("touch $file");
+
+	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+		print STDERR "make $obj failed: $rv\n";
+		next;
+	}
+
+	system("cp $file =$file");
+	for($j=@lines-1; $j>=0; $j--){
+		if($lines[$j] =~ /^#include/){
+			$old = $lines[$j];
+			$lines[$j] = "/* CUT-H */\n";
+			writefile($file, @lines);
+			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
+				$lines[$j] = $old;
+			}else{
+				print STDERR "$file $old";
+			}
+		}
+	}
+	writefile($file, grep {!/CUT-H/} @lines);
+	system("rm =$file");
+}
diff --git a/defs.h b/defs.h
index 43431e3..56e89f1 100644
--- a/defs.h
+++ b/defs.h
@@ -105,7 +105,7 @@ int             pipewrite(struct pipe*, char*, int);
 //PAGEBREAK: 16
 // proc.c
 struct proc*    copyproc(struct proc*);
-void            exit(void);
+void            exit(int);
 int             fork(void);
 int             growproc(int);
 int             kill(int);
@@ -115,7 +115,14 @@ void            scheduler(void) __attribute__((noreturn));
 void            sched(void);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
-int             wait(void);
+int             wait(int*);
+int             waitpid(int, int*, int);
+int             wait_stat(int*, int*, int*, int*);
+int             list_pgroup(int, process_info_entry*, int* size);
+int             foreground(int);
+int 			set_priority(int);
+
+
 void            wakeup(void*);
 void            yield(void);
 
diff --git a/dot-bochsrc b/dot-bochsrc
new file mode 100755
index 0000000..ba13db7
--- /dev/null
+++ b/dot-bochsrc
@@ -0,0 +1,738 @@
+# You may now use double quotes around pathnames, in case
+# your pathname includes spaces.
+
+#=======================================================================
+# CONFIG_INTERFACE
+#
+# The configuration interface is a series of menus or dialog boxes that
+# allows you to change all the settings that control Bochs's behavior.
+# There are two choices of configuration interface: a text mode version
+# called "textconfig" and a graphical version called "wx".  The text
+# mode version uses stdin/stdout and is always compiled in.  The graphical
+# version is only available when you use "--with-wx" on the configure 
+# command.  If you do not write a config_interface line, Bochs will 
+# choose a default for you.
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#=======================================================================
+#config_interface: textconfig
+#config_interface: wx
+
+#=======================================================================
+# DISPLAY_LIBRARY
+#
+# The display library is the code that displays the Bochs VGA screen.  Bochs 
+# has a selection of about 10 different display library implementations for 
+# different platforms.  If you run configure with multiple --with-* options, 
+# the display_library command lets you choose which one you want to run with.
+# If you do not write a display_library line, Bochs will choose a default for
+# you.
+#
+# The choices are: 
+#   x              use X windows interface, cross platform
+#   win32          use native win32 libraries
+#   carbon         use Carbon library (for MacOS X)
+#   beos           use native BeOS libraries
+#   macintosh      use MacOS pre-10
+#   amigaos        use native AmigaOS libraries
+#   sdl            use SDL library, cross platform
+#   svga           use SVGALIB library for Linux, allows graphics without X11
+#   term           text only, uses curses/ncurses library, cross platform
+#   rfb            provides an interface to AT&T's VNC viewer, cross platform
+#   wx             use wxWidgets library, cross platform
+#   nogui          no display at all
+#
+# NOTE: if you use the "wx" configuration interface, you must also use
+# the "wx" display library.
+#
+# Specific options:
+# Some display libraries now support specific option to control their
+# behaviour. See the examples below for currently supported options.
+#=======================================================================
+#display_library: amigaos
+#display_library: beos
+#display_library: carbon
+#display_library: macintosh
+#display_library: nogui
+#display_library: rfb, options="timeout=60" # time to wait for client
+#display_library: sdl, options="fullscreen" # startup in fullscreen mode
+#display_library: term
+#display_library: win32, options="legacyF12" # use F12 to toggle mouse
+#display_library: wx
+#display_library: x
+
+#=======================================================================
+# ROMIMAGE:
+# The ROM BIOS controls what the PC does when it first powers on.
+# Normally, you can use a precompiled BIOS in the source or binary
+# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
+# starting at address 0xf0000, and it is exactly 64k long.
+# You can also use the environment variable $BXSHARE to specify the
+# location of the BIOS.
+# The usage of external large BIOS images (up to 512k) at memory top is
+# now supported, but we still recommend to use the BIOS distributed with
+# Bochs. Now the start address can be calculated from image size.
+#=======================================================================
+romimage: file=$BXSHARE/BIOS-bochs-latest
+#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top
+#romimage: file=mybios.bin # calculate start address from image size
+
+#=======================================================================
+# CPU:
+# This defines cpu-related parameters inside Bochs:
+#
+#  COUNT:
+#  Set the number of processors when Bochs is compiled for SMP emulation.
+#  Bochs currently supports up to 8 processors. If Bochs is compiled
+#  without SMP support, it won't accept values different from 1.
+#
+#  IPS:
+#  Emulated Instructions Per Second.  This is the number of IPS that bochs
+#  is capable of running on your machine. You can recompile Bochs with
+#  --enable-show-ips option enabled, to find your workstation's capability.
+#  Measured IPS value will then be logged into your log file or status bar
+#  (if supported by the gui).
+#
+#  IPS is used to calibrate many time-dependent events within the bochs 
+#  simulation.  For example, changing IPS affects the frequency of VGA
+#  updates, the duration of time before a key starts to autorepeat, and
+#  the measurement of BogoMips and other benchmarks.
+#
+#  Examples:
+#  Machine                                         Mips
+# ________________________________________________________________
+#  2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
+#  1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
+#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
+#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
+#=======================================================================
+cpu: count=2, ips=10000000
+
+#=======================================================================
+# MEGS
+# Set the number of Megabytes of physical memory you want to emulate. 
+# The default is 32MB, most OS's won't need more than that.
+# The maximum amount of memory supported is 2048Mb.
+#=======================================================================
+#megs: 256
+#megs: 128
+#megs: 64
+megs: 32
+#megs: 16
+#megs: 8
+
+#=======================================================================
+# OPTROMIMAGE[1-4]:
+# You may now load up to 4 optional ROM images. Be sure to use a 
+# read-only area, typically between C8000 and EFFFF. These optional
+# ROM images should not overwrite the rombios (located at
+# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
+# Those ROM images will be initialized by the bios if they contain 
+# the right signature (0x55AA) and a valid checksum.
+# It can also be a convenient way to upload some arbitrary code/data
+# in the simulation, that can be retrieved by the boot loader
+#=======================================================================
+#optromimage1: file=optionalrom.bin, address=0xd0000
+#optromimage2: file=optionalrom.bin, address=0xd1000
+#optromimage3: file=optionalrom.bin, address=0xd2000
+#optromimage4: file=optionalrom.bin, address=0xd3000
+
+#optramimage1: file=/path/file1.img, address=0x0010000
+#optramimage2: file=/path/file2.img, address=0x0020000
+#optramimage3: file=/path/file3.img, address=0x0030000
+#optramimage4: file=/path/file4.img, address=0x0040000
+
+#=======================================================================
+# VGAROMIMAGE
+# You now need to load a VGA ROM BIOS into C0000.
+#=======================================================================
+#vgaromimage: file=bios/VGABIOS-elpin-2.40
+vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
+#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
+
+#=======================================================================
+# VGA:
+# Here you can specify the display extension to be used. With the value
+# 'none' you can use standard VGA with no extension. Other supported
+# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
+#=======================================================================
+#vga: extension=cirrus
+#vga: extension=vbe
+vga: extension=none
+
+#=======================================================================
+# FLOPPYA:
+# Point this to pathname of floppy image file or device
+# This should be of a bootable floppy(image/device) if you're
+# booting from 'a' (or 'floppy').
+#
+# You can set the initial status of the media to 'ejected' or 'inserted'.
+#   floppya: 2_88=path, status=ejected             (2.88M 3.5" floppy)
+#   floppya: 1_44=path, status=inserted            (1.44M 3.5" floppy)
+#   floppya: 1_2=path, status=ejected              (1.2M  5.25" floppy)
+#   floppya: 720k=path, status=inserted            (720K  3.5" floppy)
+#   floppya: 360k=path, status=inserted            (360K  5.25" floppy)
+#   floppya: 320k=path, status=inserted            (320K  5.25" floppy)
+#   floppya: 180k=path, status=inserted            (180K  5.25" floppy)
+#   floppya: 160k=path, status=inserted            (160K  5.25" floppy)
+#   floppya: image=path, status=inserted           (guess type from image size)
+#
+# The path should be the name of a disk image file.  On Unix, you can use a raw
+# device name such as /dev/fd0 on Linux.  On win32 platforms, use drive letters
+# such as a: or b: as the path.  The parameter 'image' works with image files
+# only. In that case the size must match one of the supported types.
+#=======================================================================
+floppya: 1_44=/dev/fd0, status=inserted
+#floppya: image=../1.44, status=inserted
+#floppya: 1_44=/dev/fd0H1440, status=inserted
+#floppya: 1_2=../1_2, status=inserted
+#floppya: 1_44=a:, status=inserted
+#floppya: 1_44=a.img, status=inserted
+#floppya: 1_44=/dev/rfd0a, status=inserted
+
+#=======================================================================
+# FLOPPYB:
+# See FLOPPYA above for syntax
+#=======================================================================
+#floppyb: 1_44=b:, status=inserted
+floppyb: 1_44=b.img, status=inserted
+
+#=======================================================================
+# ATA0, ATA1, ATA2, ATA3
+# ATA controller for hard disks and cdroms
+#
+# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
+# 
+# These options enables up to 4 ata channels. For each channel
+# the two base io addresses and the irq must be specified.
+# 
+# ata0 and ata1 are enabled by default with the values shown below
+#
+# Examples:
+#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
+#=======================================================================
+ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
+ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
+ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
+ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9
+
+#=======================================================================
+# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
+#
+# This defines the type and characteristics of all attached ata devices:
+#   type=       type of attached device [disk|cdrom] 
+#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
+#   mode=       only valid for disks [undoable|growing|volatile]
+#   path=       path of the image
+#   cylinders=  only valid for disks
+#   heads=      only valid for disks
+#   spt=        only valid for disks
+#   status=     only valid for cdroms [inserted|ejected]
+#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
+#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
+#   model=      string returned by identify device command
+#   journal=    optional filename of the redolog for undoable and volatile disks
+#   
+# Point this at a hard disk image file, cdrom iso file, or physical cdrom
+# device.  To create a hard disk image, try running bximage.  It will help you
+# choose the size and then suggest a line that works with it.
+#
+# In UNIX it may be possible to use a raw device as a Bochs hard disk, 
+# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
+#
+# In windows, the drive letter + colon notation should be used for cdroms.
+# Depending on versions of windows and drivers, you may only be able to 
+# access the "first" cdrom in the system.  On MacOSX, use path="drive"
+# to access the physical drive.
+#
+# The path is always mandatory. For flat hard disk images created with
+# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
+# calculated using heads=16 and spt=63). For other hard disk images and modes
+# the cylinders, heads, and spt are mandatory.
+#
+# Default values are:
+#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
+#
+# The biosdetect option has currently no effect on the bios
+#
+# Examples:
+#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
+#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
+#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
+#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
+#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
+#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
+#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
+#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
+#=======================================================================
+ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
+ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
+#ata0-slave: type=cdrom, path=D:, status=inserted
+#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
+#ata0-slave: type=cdrom, path="drive", status=inserted
+#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
+
+#=======================================================================
+# BOOT:
+# This defines the boot sequence. Now you can specify up to 3 boot drives.
+# You can either boot from 'floppy', 'disk' or 'cdrom'
+# legacy 'a' and 'c' are also supported
+# Examples:
+#   boot: floppy
+#   boot: disk
+#   boot: cdrom
+#   boot: c
+#   boot: a
+#   boot: cdrom, floppy, disk
+#=======================================================================
+#boot: floppy
+boot: disk
+
+#=======================================================================
+# CLOCK:
+# This defines the parameters of the clock inside Bochs:
+#
+#  SYNC:
+#  TO BE COMPLETED (see Greg explanation in feature request #536329)
+#
+#  TIME0:
+#  Specifies the start (boot) time of the virtual machine. Use a time 
+#  value as returned by the time(2) system call. If no time0 value is 
+#  set or if time0 equal to 1 (special case) or if time0 equal 'local', 
+#  the simulation will be started at the current local host time.
+#  If time0 equal to 2 (special case) or if time0 equal 'utc',
+#  the simulation will be started at the current utc time.
+#
+# Syntax:
+#  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]
+#
+# Example:
+#   clock: sync=none,     time0=local       # Now (localtime)
+#   clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980
+#   clock: sync=none,     time0=631148400   # Mon Jan  1 00:00:00 1990
+#   clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999
+#   clock: sync=realtime, time0=946681200   # Sat Jan  1 00:00:00 2000
+#   clock: sync=none,     time0=1           # Now (localtime)
+#   clock: sync=none,     time0=utc         # Now (utc/gmt)
+# 
+# Default value are sync=none, time0=local
+#=======================================================================
+#clock: sync=none, time0=local
+
+
+#=======================================================================
+# FLOPPY_BOOTSIG_CHECK: disabled=[0|1]
+# Enables or disables the 0xaa55 signature check on boot floppies
+# Defaults to disabled=0
+# Examples:
+#   floppy_bootsig_check: disabled=0
+#   floppy_bootsig_check: disabled=1
+#=======================================================================
+#floppy_bootsig_check: disabled=1
+floppy_bootsig_check: disabled=0
+
+#=======================================================================
+# LOG:
+# Give the path of the log file you'd like Bochs debug and misc. verbiage
+# to be written to. If you don't use this option or set the filename to
+# '-' the output is written to the console. If you really don't want it,
+# make it "/dev/null" (Unix) or "nul" (win32). :^(
+#
+# Examples:
+#   log: ./bochs.out
+#   log: /dev/tty
+#=======================================================================
+#log: /dev/null
+log: bochsout.txt
+
+#=======================================================================
+# LOGPREFIX:
+# This handles the format of the string prepended to each log line.
+# You may use those special tokens :
+#   %t : 11 decimal digits timer tick
+#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
+#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
+#   %d : 5 characters string of the device, between brackets
+# 
+# Default : %t%e%d
+# Examples:
+#   logprefix: %t-%e-@%i-%d
+#   logprefix: %i%e%d
+#=======================================================================
+#logprefix: %t%e%d
+
+#=======================================================================
+# LOG CONTROLS
+#
+# Bochs now has four severity levels for event logging.
+#   panic: cannot proceed.  If you choose to continue after a panic, 
+#          don't be surprised if you get strange behavior or crashes.
+#   error: something went wrong, but it is probably safe to continue the
+#          simulation.
+#   info: interesting or useful messages.
+#   debug: messages useful only when debugging the code.  This may
+#          spit out thousands per second.
+#
+# For events of each level, you can choose to crash, report, or ignore.
+# TODO: allow choice based on the facility: e.g. crash on panics from
+#       everything except the cdrom, and only report those.
+#
+# If you are experiencing many panics, it can be helpful to change
+# the panic action to report instead of fatal.  However, be aware
+# that anything executed after a panic is uncharted territory and can 
+# cause bochs to become unstable.  The panic is a "graceful exit," so
+# if you disable it you may get a spectacular disaster instead.
+#=======================================================================
+panic: action=ask
+error: action=report
+info: action=report
+debug: action=ignore
+#pass: action=fatal
+
+#=======================================================================
+# DEBUGGER_LOG:
+# Give the path of the log file you'd like Bochs to log debugger output.
+# If you really don't want it, make it /dev/null or '-'. :^(
+#
+# Examples:
+#   debugger_log: ./debugger.out
+#=======================================================================
+#debugger_log: /dev/null
+#debugger_log: debugger.out
+debugger_log: -
+
+#=======================================================================
+# COM1, COM2, COM3, COM4:
+# This defines a serial port (UART type 16550A). In the 'term' you can specify
+# a device to use as com1. This can be a real serial line, or a pty.  To use
+# a pty (under X/Unix), create two windows (xterms, usually).  One of them will
+# run bochs, and the other will act as com1. Find out the tty the com1
+# window using the `tty' command, and use that as the `dev' parameter.
+# Then do `sleep 1000000' in the com1 window to keep the shell from
+# messing with things, and run bochs in the other window.  Serial I/O to
+# com1 (port 0x3f8) will all go to the other window.
+# Other serial modes are 'null' (no input/output), 'file' (output to a file
+# specified as the 'dev' parameter), 'raw' (use the real serial port - under
+# construction for win32), 'mouse' (standard serial mouse - requires
+# mouse option setting 'type=serial' or 'type=serial_wheel') and 'socket'
+# (connect a networking socket).
+#
+# Examples:
+#   com1: enabled=1, mode=null
+#   com1: enabled=1, mode=mouse
+#   com2: enabled=1, mode=file, dev=serial.out
+#   com3: enabled=1, mode=raw, dev=com1
+#   com3: enabled=1, mode=socket, dev=localhost:8888
+#=======================================================================
+#com1: enabled=1, mode=term, dev=/dev/ttyp9
+
+
+#=======================================================================
+# PARPORT1, PARPORT2:
+# This defines a parallel (printer) port. When turned on and an output file is
+# defined the emulated printer port sends characters printed by the guest OS
+# into the output file. On some platforms a device filename can be used to
+# send the data to the real parallel port (e.g. "/dev/lp0" on Linux, "lpt1" on
+# win32 platforms).
+#
+# Examples:
+#   parport1: enabled=1, file="parport.out"
+#   parport2: enabled=1, file="/dev/lp0"
+#   parport1: enabled=0
+#=======================================================================
+parport1: enabled=1, file="/dev/stdout"
+
+#=======================================================================
+# SB16:
+# This defines the SB16 sound emulation. It can have several of the
+# following properties.
+# All properties are in the format sb16: property=value
+# midi: The filename is where the midi data is sent. This can be a
+#       device or just a file if you want to record the midi data.
+# midimode:
+#      0=no data
+#      1=output to device (system dependent. midi denotes the device driver)
+#      2=SMF file output, including headers
+#      3=output the midi data stream to the file (no midi headers and no
+#        delta times, just command and data bytes)
+# wave: This is the device/file where wave output is stored
+# wavemode:
+#      0=no data
+#      1=output to device (system dependent. wave denotes the device driver)
+#      2=VOC file output, incl. headers
+#      3=output the raw wave stream to the file
+# log:  The file to write the sb16 emulator messages to.
+# loglevel:
+#      0=no log
+#      1=resource changes, midi program and bank changes
+#      2=severe errors
+#      3=all errors
+#      4=all errors plus all port accesses
+#      5=all errors and port accesses plus a lot of extra info
+# dmatimer:
+#      microseconds per second for a DMA cycle.  Make it smaller to fix
+#      non-continuous sound.  750000 is usually a good value.  This needs a
+#      reasonably correct setting for the IPS parameter of the CPU option.
+#
+# For an example look at the next line:
+#=======================================================================
+
+#sb16: midimode=1, midi=/dev/midi00, wavemode=1, wave=/dev/dsp, loglevel=2, log=sb16.log, dmatimer=600000
+
+#=======================================================================
+# VGA_UPDATE_INTERVAL:
+# Video memory is scanned for updates and screen updated every so many
+# virtual seconds.  The default is 40000, about 25Hz. Keep in mind that
+# you must tweak the 'cpu: ips=N' directive to be as close to the number
+# of emulated instructions-per-second your workstation can do, for this
+# to be accurate.
+#
+# Examples:
+#   vga_update_interval: 250000
+#=======================================================================
+vga_update_interval: 300000
+
+# using for Winstone '98 tests
+#vga_update_interval:  100000
+
+#=======================================================================
+# KEYBOARD_SERIAL_DELAY:
+# Approximate time in microseconds that it takes one character to
+# be transfered from the keyboard to controller over the serial path.
+# Examples:
+#   keyboard_serial_delay: 200
+#=======================================================================
+keyboard_serial_delay: 250
+
+#=======================================================================
+# KEYBOARD_PASTE_DELAY:
+# Approximate time in microseconds between attempts to paste
+# characters to the keyboard controller. This leaves time for the
+# guest os to deal with the flow of characters.  The ideal setting
+# depends on how your operating system processes characters.  The
+# default of 100000 usec (.1 seconds) was chosen because it works 
+# consistently in Windows.
+#
+# If your OS is losing characters during a paste, increase the paste
+# delay until it stops losing characters.
+#
+# Examples:
+#   keyboard_paste_delay: 100000
+#=======================================================================
+keyboard_paste_delay: 100000
+
+#=======================================================================
+# MOUSE: 
+# This option prevents Bochs from creating mouse "events" unless a mouse
+# is  enabled. The hardware emulation itself is not disabled by this.
+# You can turn the mouse on by setting enabled to 1, or turn it off by
+# setting enabled to 0. Unless you have a particular reason for enabling
+# the mouse by default, it is recommended that you leave it off.
+# You can also toggle the mouse usage at runtime (control key + middle
+# mouse button on X11, SDL, wxWidgets and Win32).
+# With the mouse type option you can select the type of mouse to emulate.
+# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
+# on PS/2), 'serial', 'serial_wheel' (one com port requires setting
+# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
+# connected with the 'mouse' device - requires PCI and USB support).
+#
+# Examples:
+#   mouse: enabled=1
+#   mouse: enabled=1, type=imps2
+#   mouse: enabled=1, type=serial
+#   mouse: enabled=0
+#=======================================================================
+mouse: enabled=0
+
+#=======================================================================
+# private_colormap: Request that the GUI create and use it's own
+#                   non-shared colormap.  This colormap will be used
+#                   when in the bochs window.  If not enabled, a
+#                   shared colormap scheme may be used.  Not implemented
+#                   on all GUI's.
+#
+# Examples:
+#   private_colormap: enabled=1
+#   private_colormap: enabled=0
+#=======================================================================
+private_colormap: enabled=0
+
+#=======================================================================
+# fullscreen: ONLY IMPLEMENTED ON AMIGA
+#             Request that Bochs occupy the entire screen instead of a 
+#             window.
+#
+# Examples:
+#   fullscreen: enabled=0
+#   fullscreen: enabled=1
+#=======================================================================
+#fullscreen: enabled=0
+#screenmode: name="sample"
+
+#=======================================================================
+# ne2k: NE2000 compatible ethernet adapter
+#
+# Examples:
+# ne2k: ioaddr=IOADDR, irq=IRQ, mac=MACADDR, ethmod=MODULE, ethdev=DEVICE, script=SCRIPT
+#
+# ioaddr, irq: You probably won't need to change ioaddr and irq, unless there
+# are IRQ conflicts.
+#
+# mac: The MAC address MUST NOT match the address of any machine on the net.
+# Also, the first byte must be an even number (bit 0 set means a multicast
+# address), and you cannot use ff:ff:ff:ff:ff:ff because that's the broadcast
+# address.  For the ethertap module, you must use fe:fd:00:00:00:01.  There may
+# be other restrictions too.  To be safe, just use the b0:c4... address.
+#
+# ethdev: The ethdev value is the name of the network interface on your host
+# platform.  On UNIX machines, you can get the name by running ifconfig.  On
+# Windows machines, you must run niclist to get the name of the ethdev.
+# Niclist source code is in misc/niclist.c and it is included in Windows 
+# binary releases.
+#
+# script: The script value is optional, and is the name of a script that 
+# is executed after bochs initialize the network interface. You can use 
+# this script to configure this network interface, or enable masquerading.
+# This is mainly useful for the tun/tap devices that only exist during
+# Bochs execution. The network interface name is supplied to the script
+# as first parameter
+#
+# If you don't want to make connections to any physical networks,
+# you can use the following 'ethmod's to simulate a virtual network.
+#   null: All packets are discarded, but logged to a few files.
+#   arpback: ARP is simulated. Disabled by default.
+#   vde:  Virtual Distributed Ethernet
+#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
+#         The virtual host uses 192.168.10.1.
+#         DHCP assigns 192.168.10.2 to the guest.
+#         TFTP uses the ethdev value for the root directory and doesn't
+#         overwrite files.
+#
+#=======================================================================
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=fbsd, ethdev=en0 #macosx
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=fbsd, ethdev=xl0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:00, ethmod=linux, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=win32, ethdev=MYCARD
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tap, ethdev=tap0
+# ne2k: ioaddr=0x240, irq=9, mac=fe:fd:00:00:00:01, ethmod=tuntap, ethdev=/dev/net/tun0, script=./tunconfig
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=null, ethdev=eth0
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vde, ethdev="/tmp/vde.ctl"
+# ne2k: ioaddr=0x240, irq=9, mac=b0:c4:20:00:00:01, ethmod=vnet, ethdev="c:/temp"
+
+#=======================================================================
+# KEYBOARD_MAPPING:
+# This enables a remap of a physical localized keyboard to a 
+# virtualized us keyboard, as the PC architecture expects.
+# If enabled, the keymap file must be specified.
+# 
+# Examples:
+#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
+#=======================================================================
+keyboard_mapping: enabled=0, map=
+
+#=======================================================================
+# KEYBOARD_TYPE:
+# Type of keyboard return by a "identify keyboard" command to the
+# keyboard controler. It must be one of "xt", "at" or "mf".
+# Defaults to "mf". It should be ok for almost everybody. A known
+# exception is french macs, that do have a "at"-like keyboard.
+#
+# Examples:
+#   keyboard_type: mf
+#=======================================================================
+#keyboard_type: mf
+
+#=======================================================================
+# USER_SHORTCUT:
+# This defines the keyboard shortcut to be sent when you press the "user"
+# button in the headerbar. The shortcut string is a combination of maximum
+# 3 key names (listed below) separated with a '-' character. The old-style
+# syntax (without the '-') still works for the key combinations supported
+# in Bochs 2.2.1.
+# Valid key names:
+# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
+# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
+# "plus", "right", "shift", "space", "tab", "up", and "win".
+#
+# Example:
+#   user_shortcut: keys=ctrl-alt-del
+#=======================================================================
+#user_shortcut: keys=ctrl-alt-del
+
+#=======================================================================
+# I440FXSUPPORT:
+# This option controls the presence of the i440FX PCI chipset. You can
+# also specify the devices connected to PCI slots. Up to 5 slots are
+# available now. These devices are currently supported: ne2k, pcivga,
+# pcidev and pcipnic. If Bochs is compiled with Cirrus SVGA support
+# you'll have the additional choice 'cirrus'.
+#
+# Example:
+#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
+#=======================================================================
+#i440fxsupport: enabled=1
+
+#=======================================================================
+# USB1:
+# This option controls the presence of the USB root hub which is a part
+# of the i440FX PCI chipset. With the portX option you can connect devices
+# to the hub (currently supported: 'mouse' and 'keypad'). If you connect
+# the mouse to one of the ports and use the mouse option 'type=usb' you'll
+# have a 3-button USB mouse.
+#
+# Example:
+#   usb1: enabled=1, port1=mouse, port2=keypad
+#=======================================================================
+#usb1: enabled=1
+
+#=======================================================================
+# CMOSIMAGE:
+# This defines image file that can be loaded into the CMOS RAM at startup.
+# The rtc_init parameter controls whether initialize the RTC with values stored
+# in the image. By default the time0 argument given to the clock option is used.
+# With 'rtc_init=image' the image is the source for the initial time.
+#
+# Example:
+#   cmosimage: file=cmos.img, rtc_init=image
+#=======================================================================
+#cmosimage: file=cmos.img, rtc_init=time0
+
+#=======================================================================
+# other stuff
+#=======================================================================
+#magic_break: enabled=1
+#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
+#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
+#text_snapshot_check: enable
+
+#-------------------------
+# PCI host device mapping
+#-------------------------
+#pcidev: vendor=0x1234, device=0x5678
+
+#=======================================================================
+# GDBSTUB:
+# Enable GDB stub. See user documentation for details.
+# Default value is enabled=0.
+#=======================================================================
+#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0
+
+#=======================================================================
+# IPS:
+# The IPS directive is DEPRECATED. Use the parameter IPS of the CPU
+# directive instead.
+#=======================================================================
+#ips: 10000000
+
+#=======================================================================
+# for Macintosh, use the style of pathnames in the following
+# examples.
+#
+# vgaromimage: :bios:VGABIOS-elpin-2.40
+# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
+# floppya: 1_44=[fd:], status=inserted
+#=======================================================================
diff --git a/echo.c b/echo.c
index 806dee0..04ff01d 100644
--- a/echo.c
+++ b/echo.c
@@ -9,5 +9,5 @@ main(int argc, char *argv[])
 
   for(i = 1; i < argc; i++)
     printf(1, "%s%s", argv[i], i+1 < argc ? " " : "\n");
-  exit();
+  exit(EXIT_STATUS_SUCCESS);
 }
diff --git a/exec.c b/exec.c
index 8dbbdb6..c3adbc1 100644
--- a/exec.c
+++ b/exec.c
@@ -7,6 +7,9 @@
 #include "x86.h"
 #include "elf.h"
 
+extern void implicit_exit();
+extern void implicit_exit_end();
+
 int
 exec(char *path, char **argv)
 {
@@ -53,13 +56,22 @@ exec(char *path, char **argv)
   end_op();
   ip = 0;
 
+	//calculating implicit return function size
+  int retFuncSize = implicit_exit_end - implicit_exit;
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+
+  if((sz = allocuvm(pgdir, sz, sz + (2*PGSIZE + retFuncSize))) == 0)
+    goto bad;
+  clearpteu(pgdir, (char*)(sz - (2*PGSIZE + retFuncSize)));
+
+	//setting sp to function start place
+  sp = sz - retFuncSize;
+  if(copyout(pgdir, sp, implicit_exit, retFuncSize) < 0)
     goto bad;
-  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
-  sp = sz;
+
+  uint userRetFuncAddress = sp;
 
   // Push argument strings, prepare rest of stack in ustack.
   for(argc = 0; argv[argc]; argc++) {
@@ -72,7 +84,9 @@ exec(char *path, char **argv)
   }
   ustack[3+argc] = 0;
 
-  ustack[0] = 0xffffffff;  // fake return PC
+
+
+  ustack[0] = userRetFuncAddress;  // fake return PC
   ustack[1] = argc;
   ustack[2] = sp - (argc+1)*4;  // argv pointer
 
@@ -85,7 +99,6 @@ exec(char *path, char **argv)
     if(*s == '/')
       last = s+1;
   safestrcpy(proc->name, last, sizeof(proc->name));
-
   // Commit to the user image.
   oldpgdir = proc->pgdir;
   proc->pgdir = pgdir;
diff --git a/file.c b/file.c
index 98cad1e..1b72b42 100644
--- a/file.c
+++ b/file.c
@@ -91,6 +91,7 @@ filestat(struct file *f, struct stat *st)
   return -1;
 }
 
+
 // Read from file f.
 int
 fileread(struct file *f, char *addr, int n)
diff --git a/forktest.c b/forktest.c
index bb286e6..bea40f5 100644
--- a/forktest.c
+++ b/forktest.c
@@ -25,24 +25,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
   }
   
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(0) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   
-  if(wait() != -1){
+  if(wait(0) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   
   printf(1, "fork test OK\n");
@@ -52,5 +52,5 @@ int
 main(void)
 {
   forktest();
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/gdbutil b/gdbutil
new file mode 100644
index 0000000..e0c362f
--- /dev/null
+++ b/gdbutil
@@ -0,0 +1,291 @@
+# -*- gdb-script -*-
+
+# Utility functions to pretty-print x86 segment/interrupt descriptors.
+# To load this file, run "source gdbutil" in gdb.
+# printdesc and printdescs are the main entry points.
+
+# IA32 2007, Volume 3A, Table 3-2
+set $STS_T16A = 0x1
+set $STS_LDT  = 0x2
+set $STS_T16B = 0x3
+set $STS_CG16 = 0x4
+set $STS_TG   = 0x5
+set $STS_IG16 = 0x6
+set $STS_TG16 = 0x7
+set $STS_T32A = 0x9
+set $STS_T32B = 0xB
+set $STS_CG32 = 0xC
+set $STS_IG32 = 0xE
+set $STS_TG32 = 0xF
+
+define outputsts
+  while 1
+    if $arg0 == $STS_T16A
+      echo STS_T16A
+      loop_break
+    end
+    if $arg0 == $STS_LDT
+      echo STS_LDT\ 
+      loop_break
+    end
+    if $arg0 == $STS_T16B
+      echo STS_T16B
+      loop_break
+    end
+    if $arg0 == $STS_CG16
+      echo STS_CG16
+      loop_break
+    end
+    if $arg0 == $STS_TG
+      echo STS_TG\ \ 
+      loop_break
+    end
+    if $arg0 == $STS_IG16
+      echo STS_IG16
+      loop_break
+    end
+    if $arg0 == $STS_TG16
+      echo STS_TG16
+      loop_break
+    end
+    if $arg0 == $STS_T32A
+      echo STS_T32A
+      loop_break
+    end
+    if $arg0 == $STS_T32B
+      echo STS_T32B
+      loop_break
+    end
+    if $arg0 == $STS_CG32
+      echo STS_CG32
+      loop_break
+    end
+    if $arg0 == $STS_IG32
+      echo STS_IG32
+      loop_break
+    end
+    if $arg0 == $STS_TG32
+      echo STS_TG32
+      loop_break
+    end
+    echo Reserved
+    loop_break
+  end
+end  
+
+# IA32 2007, Volume 3A, Table 3-1
+set $STA_X = 0x8
+set $STA_E = 0x4
+set $STA_C = 0x4
+set $STA_W = 0x2
+set $STA_R = 0x2
+set $STA_A = 0x1
+
+define outputsta
+  if $arg0 & $STA_X
+    # Code segment
+    echo code
+    if $arg0 & $STA_C
+      echo |STA_C
+    end
+    if $arg0 & $STA_R
+      echo |STA_R
+    end
+  else
+    # Data segment
+    echo data
+    if $arg0 & $STA_E
+      echo |STA_E
+    end
+    if $arg0 & $STA_W
+      echo |STA_W
+    end
+  end
+  if $arg0 & $STA_A
+    echo |STA_A
+  else
+    printf "      "
+  end
+end
+
+# xv6-specific
+set $SEG_KCODE = 1
+set $SEG_KDATA = 2
+set $SEG_KCPU  = 3
+set $SEG_UCODE = 4
+set $SEG_UDATA = 5
+set $SEG_TSS   = 6
+
+define outputcs
+  if ($arg0 & 4) == 0
+    if $arg0 >> 3 == $SEG_KCODE
+      printf "SEG_KCODE<<3"
+    end
+    if $arg0 >> 3 == $SEG_KDATA
+      printf "SEG_KDATA<<3"
+    end
+    if $arg0 >> 3 == $SEG_KCPU
+      printf "SEG_KCPU<<3"
+    end
+    if $arg0 >> 3 == $SEG_UCODE
+      printf "SEG_UCODE<<3"
+    end
+    if $arg0 >> 3 == $SEG_UDATA
+      printf "SEG_UDATA<<3"
+    end
+    if $arg0 >> 3 == $SEG_TSS
+      printf "SEG_TSS<<3"
+    end
+    if ($arg0 >> 3 < 1) + ($arg0 >> 3 > 6)
+      printf "GDT[%d]", $arg0 >> 3
+    end
+  else
+    printf "LDT[%d]", $arg0 >> 3
+  end
+  if ($arg0 & 3) > 0
+    printf "|"
+    outputdpl ($arg0&3)
+  end
+end
+
+define outputdpl
+  if $arg0 == 0
+    printf "DPL_KERN"
+  else
+    if $arg0 == 3
+      printf "DPL_USER"
+    else
+      printf "DPL%d", $arg0
+    end
+  end
+end
+
+define printdesc
+  if $argc != 1
+    echo Usage: printdesc expr
+  else
+    _printdesc ((uint*)&($arg0))[0] ((uint*)&($arg0))[1]
+    printf "\n"
+  end
+end
+
+document printdesc
+Print an x86 segment or gate descriptor.
+printdesc EXPR
+EXPR must evaluate to a descriptor value.  It can be of any C type.
+end
+
+define _printdesc
+  _printdesc1 $arg0 $arg1 ($arg1>>15&1) ($arg1>>13&3) ($arg1>>12&1) ($arg1>>8&15)
+end
+
+define _printdesc1
+  # 2:P 3:DPL 4:S 5:Type
+  if $arg2 == 0
+    printf "P = 0 (Not present)"
+  else
+    printf "type = "
+    if $arg4 == 0
+      # System segment
+      outputsts $arg5
+      printf " (0x%x)    ", $arg5
+      _printsysdesc $arg0 $arg1 $arg5
+    else
+      # Code/data segment
+      outputsta $arg5
+      printf "  "
+      _printsegdesc $arg0 $arg1
+    end
+
+    printf "  DPL = "
+    outputdpl $arg3
+    printf " (%d)", $arg3
+  end
+end
+
+define _printsysdesc
+  # 2:Type
+  # GDB's || is buggy
+  if ($arg2 == $STS_TG) + (($arg2&7) == $STS_IG16) + (($arg2&7) == $STS_TG16)
+    # Gate descriptor
+    _printgate $arg2 ($arg0>>16) ($arg0&0xFFFF) ($arg1>>16)
+  else
+    # System segment descriptor
+    _printsegdesc $arg0 $arg1
+  end
+end
+
+define _printgate
+  # IA32 2007, Voume 3A, Figure 5-2
+  # 0:Type 1:CS 2:Offset 15..0 3:Offset 31..16
+  printf "CS = "
+  outputcs $arg1
+  printf " (%d)", $arg1
+
+  if (($arg0&7) == $STS_IG16) + (($arg0&7) == $STS_TG16)
+    printf "  Offset = "
+    output/a $arg3 << 16 | $arg2
+  end
+end
+
+define _printsegdesc
+  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
+  _printsegdesc1 ($arg0>>16) ($arg1&0xFF) ($arg1>>24) ($arg0&0xFFFF) ($arg1>>16&15) ($arg1>>23&1)
+  if ($arg1>>12&1) == 1
+    printf "  AVL = %d", $arg1>>20&1
+    if ($arg1>>11&1) == 0
+      # Data segment
+      if ($arg1>>22&1) == 0
+        printf "  B = small (0) "
+      else
+        printf "  B = big (1)   "
+      end
+    else
+      # Code segment
+      printf "  D = "
+      if ($arg1>>22&1) == 0
+        printf "16-bit (0)"
+      else
+        printf "32-bit (1)"
+      end
+    end
+  end
+end
+
+define _printsegdesc1
+  # 0:Base 0..15  1:Base 16..23  2:Base 24..32  3:Limit 0..15  4:Limit 16..19  5:G
+  printf "base = 0x%08x", $arg0 | ($arg1<<16) | ($arg2<<24)
+  printf "  limit = 0x"
+  if $arg5 == 0
+    printf "%08x", $arg3 | ($arg4<<16)
+  else
+    printf "%08x", (($arg3 | ($arg4<<16)) << 12) | 0xFFF
+  end
+end
+
+define printdescs
+  if $argc < 1 || $argc > 2
+    echo Usage: printdescs expr [count]
+  else
+    if $argc == 1
+      _printdescs ($arg0) (sizeof($arg0)/sizeof(($arg0)[0]))
+    else
+      _printdescs ($arg0) ($arg1)
+    end
+  end
+end
+
+document printdescs
+Print an array of x86 segment or gate descriptors.
+printdescs EXPR [COUNT]
+EXPR must evaluate to an array of descriptors.
+end
+
+define _printdescs
+  set $i = 0
+  while $i < $arg1
+    printf "[%d] ", $i
+    printdesc $arg0[$i]
+    set $i = $i + 1
+  end
+end
diff --git a/grep.c b/grep.c
index 2fbf5b6..9c1f0c9 100644
--- a/grep.c
+++ b/grep.c
@@ -42,24 +42,24 @@ main(int argc, char *argv[])
   
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   pattern = argv[1];
   
   if(argc <= 2){
     grep(pattern, 0);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 2; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     grep(pattern, fd);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
 
 // Regexp matcher from Kernighan & Pike,
diff --git a/implicit_return.S b/implicit_return.S
new file mode 100644
index 0000000..816cfd3
--- /dev/null
+++ b/implicit_return.S
@@ -0,0 +1,13 @@
+
+.code32
+.globl implicit_exit
+.globl implicit_exit_end
+
+implicit_exit:
+	push %eax
+	push $0xffffffff #fake address
+
+	movl $2, %eax;
+	int $64;
+
+implicit_exit_end:
diff --git a/init.c b/init.c
index 046b551..1199333 100644
--- a/init.c
+++ b/init.c
@@ -24,14 +24,14 @@ main(void)
     pid = fork();
     if(pid < 0){
       printf(1, "init: fork failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(pid == 0){
       exec("sh", argv);
       printf(1, "init: exec sh failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
-    while((wpid=wait()) >= 0 && wpid != pid)
+    while((wpid=wait(0)) >= 0 && wpid != pid)
       printf(1, "zombie!\n");
   }
 }
diff --git a/initcode.S b/initcode.S
index 109341a..748b6a7 100644
--- a/initcode.S
+++ b/initcode.S
@@ -13,7 +13,7 @@ start:
   movl $SYS_exec, %eax
   int $T_SYSCALL
 
-# for(;;) exit();
+# for(;;) exit(EXIT_STATUS_DEFAULT);
 exit:
   movl $SYS_exit, %eax
   int $T_SYSCALL
diff --git a/kill.c b/kill.c
index 5e60113..51847be 100644
--- a/kill.c
+++ b/kill.c
@@ -9,9 +9,9 @@ main(int argc, char **argv)
 
   if(argc < 1){
     printf(2, "usage: kill pid...\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   for(i=1; i<argc; i++)
     kill(atoi(argv[i]));
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/linkedList.c b/linkedList.c
new file mode 100644
index 0000000..80b9789
--- /dev/null
+++ b/linkedList.c
@@ -0,0 +1,160 @@
+#include "linkedList.h"
+#include "types.h"
+#include "defs.h"
+
+struct node* create_link(linkedList* list){
+	int i;
+	for (i = 0; i < LINKED_LIST_SIZE; i++) {
+		if(!list->nodes[i].used){
+			list->nodes[i].used = 1;
+			return &list->nodes[i];
+		}
+	}
+
+	//error not found
+	cprintf("Error: linkedlist: cant create new link, list at full capacity!\n");
+	return 0;
+}
+
+void clean_up(struct node* link){
+	link->id = 0;
+	link->data = 0;
+	link->next = 0;
+	link->prev = 0;
+	link->used = 0;
+}
+
+void add_last(linkedList* list, node* link){
+	if(list->head == 0){
+		list->head = link;
+		list->tail = link;
+		list->size++;
+	}
+	else{
+		link->prev = list->tail;
+		list->tail->next = link;
+		list->tail = link;
+		list->size++;
+	}
+}
+
+void add(struct linkedList* list, int id, struct proc* p){
+//	if( search(list,id) != 0 ) return; //add unique
+
+	//cprintf("(+%d)", id);
+	node* node;
+	node = create_link(list);
+	node->id = id;
+	node->data = p;
+	list->add_last(list,node);
+	//print(list);
+}
+
+
+struct proc* remove_first(linkedList* list){
+	struct proc* p;
+	node* tmp;
+	if( list->head == 0 ){
+		cprintf("ERROR: list is empty. cant remove 1st link");
+		return 0;
+	}
+	tmp = list->head;
+	//cprintf("(-%d)", tmp->id);
+	p = tmp->data;
+	list->head = list->head->next;
+	tmp->clean_up(tmp);
+	if(list->head != 0){
+		list->head->prev = 0;
+	}
+	list->size--;
+	return p;
+}
+void init_linkedList(linkedList* list,int fixed_size){
+	int i;
+	list->head = 0;
+	list->tail = 0;
+	list->size = 0;
+	list->max_size = fixed_size;
+	list->add_last = add_last;
+	list->add = add;
+	list->remove_first = remove_first;
+	list->print = print;
+	list->get_link = get_link;
+	list->remove_link = remove_link;
+	list->search = search;
+
+	for(i=0; i < fixed_size; i++){
+		list->nodes[i].clean_up = clean_up;
+		list->nodes[i].clean_up(&list->nodes[i]);
+	}
+
+}
+
+void clean_list(linkedList* list){
+	while(list->size > 0){
+		list->remove_first(list);
+	}
+}
+
+void print(linkedList* list){
+	node* link = list->head;
+
+	cprintf("LinkedList content:\n");
+
+	cprintf("HEAD");
+	while(link != 0){
+		cprintf(" => [%d ,0x%x] ",link->id,link->data);
+		link = link->next;
+	}
+	cprintf("<= TAIL \n");
+
+}
+
+node* get_link(linkedList* list,int position){
+	node* link = list->head;
+	while(position > 0 && link != 0){
+		link = link->next;
+		position--;
+	}
+	if(position == 0) return link;
+
+	return 0;
+}
+node* search(linkedList* list, int id){
+	node* p = list->head;
+
+	while(p != 0){
+		if(p->id == id){
+			return p;
+		}
+		p=p->next;
+	}
+	return 0;
+}
+
+
+int remove_link(linkedList* list,int id){
+	node* tmp = search(list,id);
+	cprintf("requested: %d, deleting, found:(%d) %d\n", id, tmp, tmp->id);
+	if(tmp != 0){
+		if(tmp->prev == 0){ /* was head*/
+			list->head = tmp->next;
+		}
+		else{
+			tmp->prev->next = tmp->next;
+			if(tmp->next != 0){
+				tmp->next->prev = tmp->prev;
+			}
+			else{
+				list->tail = tmp->prev;
+			}
+
+
+		}
+		tmp->clean_up(tmp);
+		//list->print(list);
+
+		return 1;
+	}
+	return 0;
+}
diff --git a/linkedList.h b/linkedList.h
new file mode 100644
index 0000000..523a9c5
--- /dev/null
+++ b/linkedList.h
@@ -0,0 +1,50 @@
+#define LINKED_LIST_SIZE 64
+
+typedef struct node
+{
+	int id;
+	struct proc* data;
+    struct node* next;				/* address to next node */
+    struct node* prev;				/* address to prev node */
+    int used;
+    void (*clean_up)(struct node* link);
+} node;
+
+typedef struct linkedList
+{
+	node* head;
+	node* tail;
+	int size;
+	int max_size;
+	struct node nodes[LINKED_LIST_SIZE];
+	void (*add_last)(struct linkedList* list, node* link);
+	void (*add)(struct linkedList* list, int id, struct proc* p);
+	struct proc* (*remove_first)(struct linkedList* list);
+	void (*print)(struct linkedList* list);
+	node* (*get_link)(struct linkedList* list,int position);
+	int (*remove_link)(struct linkedList* list,int id);
+	node* (*search)(struct linkedList* list,int id);
+} linkedList;
+
+
+void add(struct linkedList* list, int id, struct proc* p);
+
+struct node* create_link(linkedList* list);
+
+void add_last(linkedList* list, node* link);
+
+struct proc* remove_first(linkedList* list);
+
+void clean_up(struct node* link);
+
+void init_linkedList(linkedList* list,int fixed_size);
+
+void print(linkedList* list);
+
+node* get_link(linkedList* list,int position);
+
+void clean_up(node* link);
+
+node* search(linkedList* list,int id);
+
+int remove_link(linkedList* list,int id);
diff --git a/ln.c b/ln.c
index cf8a64e..1506075 100644
--- a/ln.c
+++ b/ln.c
@@ -7,9 +7,9 @@ main(int argc, char *argv[])
 {
   if(argc != 3){
     printf(2, "Usage: ln old new\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(link(argv[1], argv[2]) < 0)
     printf(2, "link %s %s: failed\n", argv[1], argv[2]);
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/ls.c b/ls.c
index b6ddd7f..7482334 100644
--- a/ls.c
+++ b/ls.c
@@ -77,9 +77,9 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     ls(".");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   for(i=1; i<argc; i++)
     ls(argv[i]);
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/main.c b/main.c
index 8a73c0f..143c392 100644
--- a/main.c
+++ b/main.c
@@ -10,7 +10,6 @@ static void startothers(void);
 static void mpmain(void)  __attribute__((noreturn));
 extern pde_t *kpgdir;
 extern char end[]; // first address after kernel loaded from ELF file
-
 // Bootstrap processor starts running C code here.
 // Allocate a real stack and switch to it, first
 // doing some setup required for memory allocator to work.
@@ -40,6 +39,8 @@ main(void)
   userinit();      // first user process
   // Finish setting up this processor in mpmain.
   mpmain();
+
+
 }
 
 // Other CPUs jump here from entryother.S.
@@ -59,6 +60,7 @@ mpmain(void)
   cprintf("cpu%d: starting\n", cpu->id);
   idtinit();       // load idt register
   xchg(&cpu->started, 1); // tell startothers() we're up
+
   scheduler();     // start running processes
 }
 
diff --git a/mkdir.c b/mkdir.c
index 6e4c954..41e263b 100644
--- a/mkdir.c
+++ b/mkdir.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: mkdir files...\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/param.h b/param.h
index 8e007ca..c8083c3 100644
--- a/param.h
+++ b/param.h
@@ -11,3 +11,4 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 
+#define QUANTA 5	//quanta for scheduler
diff --git a/pr.pl b/pr.pl
new file mode 100755
index 0000000..46905bd
--- /dev/null
+++ b/pr.pl
@@ -0,0 +1,36 @@
+#!/usr/bin/perl
+
+use POSIX qw(strftime);
+
+if($ARGV[0] eq "-h"){
+	shift @ARGV;
+	$h = $ARGV[0];
+	shift @ARGV;
+}else{
+	$h = $ARGV[0];
+}
+
+$page = 0;
+$now = strftime "%b %e %H:%M %Y", localtime;
+
+@lines = <>;
+for($i=0; $i<@lines; $i+=50){
+	print "\n\n";
+	++$page;
+	print "$now  $h  Page $page\n";
+	print "\n\n";
+	for($j=$i; $j<@lines && $j<$i +50; $j++){
+		$lines[$j] =~ s!//DOC.*!!;
+		print $lines[$j];
+	}
+	for(; $j<$i+50; $j++){
+		print "\n";
+	}
+	$sheet = "";
+	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
+		$sheet = "Sheet $1";
+	}
+	print "\n\n";
+	print "$sheet\n";
+	print "\n\n";
+}
diff --git a/printpcs b/printpcs
new file mode 100755
index 0000000..81d039b
--- /dev/null
+++ b/printpcs
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+# Decode the symbols from a panic EIP list
+
+# Find a working addr2line
+for p in i386-jos-elf-addr2line addr2line; do
+    if which $p 2>&1 >/dev/null && \
+       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
+        break
+    fi
+done
+
+# Enable as much pretty-printing as this addr2line can do
+$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
diff --git a/proc.c b/proc.c
index a642f5a..c372a80 100644
--- a/proc.c
+++ b/proc.c
@@ -7,6 +7,10 @@
 #include "proc.h"
 #include "spinlock.h"
 
+#include "linkedList.h"
+
+#define SHELL_PID 2
+
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -14,6 +18,10 @@ struct {
 
 static struct proc *initproc;
 
+#if defined(FRR) || defined(FCFS)
+static linkedList plist;
+#endif
+
 int nextpid = 1;
 extern void forkret(void);
 extern void trapret(void);
@@ -24,6 +32,9 @@ void
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+	#if defined(FRR) || defined(FCFS)
+	  init_linkedList(&plist,NPROC);
+	#endif
 }
 
 //PAGEBREAK: 32
@@ -47,6 +58,8 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->ctime = ticks;
+  p->priority = PRIORITY_MEDIUM;
   release(&ptable.lock);
 
   // Allocate kernel stack.
@@ -100,6 +113,13 @@ userinit(void)
   p->cwd = namei("/");
 
   p->state = RUNNABLE;
+
+  #if defined(FRR) || defined(FCFS)
+	  acquire(&ptable.lock);	//wasnt here
+	  plist.add(&plist, p->pid, p);
+	  release(&ptable.lock);
+  #endif
+
 }
 
 // Grow current process's memory by n bytes.
@@ -128,7 +148,7 @@ growproc(int n)
 int
 fork(void)
 {
-  int i, pid;
+  int i, pid, gid;
   struct proc *np;
 
   // Allocate process.
@@ -158,11 +178,32 @@ fork(void)
  
   pid = np->pid;
 
+  //Set group id
+  //if father is shell -> gid = this new process pid
+  if( proc->pid == SHELL_PID){
+	  gid = pid;
+  }
+  //else, take father gid
+  else{
+	  gid = proc->gid;
+  }
+
+  np->gid = gid;
+
+  //cprintf("\n[debug] [fork] Created a new process son of '%s' with pid %d, and guid: %d\n", np->name, pid, gid);
   // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
   np->state = RUNNABLE;
-  release(&ptable.lock);
   
+#if defined(FRR) || defined(FCFS)
+
+  plist.add(&plist, pid, np);
+#endif
+
+  release(&ptable.lock);
+
+
+
   return pid;
 }
 
@@ -170,11 +211,13 @@ fork(void)
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
 void
-exit(void)
+exit(int status)
 {
   struct proc *p;
   int fd;
 
+  //cprintf("\n[debug] [exit] Process '%s' (%d) Exited with status code %d\n", proc->name, proc->pid, status);
+
   if(proc == initproc)
     panic("init exiting");
 
@@ -191,8 +234,11 @@ exit(void)
   end_op();
   proc->cwd = 0;
 
+
   acquire(&ptable.lock);
 
+  proc->status = status;
+  proc->ttime = ticks;
   // Parent might be sleeping in wait().
   wakeup1(proc->parent);
 
@@ -209,12 +255,35 @@ exit(void)
   proc->state = ZOMBIE;
   sched();
   panic("zombie exit");
+
+
+}
+int clean_proc_entry(struct proc* p){
+	int pid;
+    // Found one.
+    pid = p->pid;
+    kfree(p->kstack);
+    p->kstack = 0;
+    freevm(p->pgdir);
+    p->state = UNUSED;
+    p->pid = 0;
+    p->parent = 0;
+    p->name[0] = 0;
+    p->killed = 0;
+    p->retime = 0;
+    p->rutime = 0;
+    p->stime = 0;
+    p->ttime = 0;
+    p->ctime = 0;
+    p->vruntime = 0;
+    p->priority = PRIORITY_MEDIUM;
+    return pid;
 }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
-wait(void)
+wait(int* status)
 {
   struct proc *p;
   int havekids, pid;
@@ -229,16 +298,14 @@ wait(void)
       havekids = 1;
       if(p->state == ZOMBIE){
         // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->state = UNUSED;
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
+        pid = clean_proc_entry(p);
+
+        if(status){ // if user did not send status=0 (do not care)
+            *status = p->status; //return status to caller
+        }
+
         release(&ptable.lock);
+
         return pid;
       }
     }
@@ -254,6 +321,234 @@ wait(void)
   }
 }
 
+//special wait function without acquire
+//this is how the shell waits for its children
+int
+shellWait(int childPid)
+{
+  struct proc *p;
+  int pid;
+
+  for(;;){
+    // Scan through table looking for zombie children.
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      if( p->pid == childPid ){
+		 if(p->state == ZOMBIE ){
+			pid = clean_proc_entry(p);
+			release(&ptable.lock);
+
+			return pid;
+		  }
+      }
+
+    }
+	sleep(proc, &ptable.lock);
+  }
+}
+
+// Wait for a child process *with a specific pid* to exit and return its pid.
+// Return -1 if this process has no children.
+int
+waitpid(int childPid, int* status, int options)
+{
+  struct proc *p;
+  int havekids, pid, isMyChild;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    isMyChild = 0;
+
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if( p->pid == childPid ){
+    	 isMyChild = 1;
+		 if(p->state == ZOMBIE ){
+			pid = clean_proc_entry(p);
+
+			if(status){ // if user did not send status=0 (do not care)
+				*status = p->status; //return status to caller
+			}
+
+			release(&ptable.lock);
+
+			return pid;
+		  }
+      }
+
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || !isMyChild || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    switch (options) {
+		case BLOCKING:
+			sleep(proc, &ptable.lock);
+			break;
+		case NONBLOCKING:
+			release(&ptable.lock);
+			return -1;
+			break;
+		default:
+			release(&ptable.lock);
+			return -1;
+			break;
+	}
+
+  }
+}
+
+int
+wait_stat(int* wtime, int* rtime, int* iotime, int* status)
+{
+	  struct proc *p;
+	  int havekids, pid;
+
+	  acquire(&ptable.lock);
+	  for(;;){
+	    // Scan through table looking for zombie children.
+	    havekids = 0;
+	    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+	      if(p->parent != proc)
+	        continue;
+	      havekids = 1;
+	      if(p->state == ZOMBIE){
+	        // Found one.
+	    	*wtime = p->retime;
+	    	*rtime = p->rutime;
+	    	*iotime = p->stime;
+
+	        pid = clean_proc_entry(p);
+
+	        if(status){ // if user did not send status=0 (do not care)
+	            *status = p->status; //return status to caller
+	        }
+
+	        release(&ptable.lock);
+
+	        return pid;
+	      }
+	    }
+
+	    // No point waiting if we don't have any children.
+	    if(!havekids || proc->killed){
+	      release(&ptable.lock);
+	      return -1;
+	    }
+
+	    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+	    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+	  }
+}
+
+int
+foreground(int gid)
+{
+	struct proc* p;
+	int pids[64];
+	int counter = 0;
+//	int i, status;
+	int i;
+	int retVal = -1;
+
+	//cprintf("called fg with gid: %d \n", gid);
+	acquire(&ptable.lock);
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+			if( ( p->state == RUNNING ||  p->state == RUNNABLE ||  p->state == SLEEPING) &&
+				(p->parent == initproc) &&
+				(p->gid == gid) )
+			{
+				p->parent = &ptable.proc[1]; //parent = shell
+				pids[counter] = p->pid;
+				counter++;
+			}
+	}
+	for(i=0; i < counter; i++){
+		//cprintf("**waiting for: %d \n ",pids[i]);
+		if (shellWait(pids[i]) != -1)	retVal = 1;
+	}
+	release(&ptable.lock);
+/*
+	for(i=0; i < counter; i++){
+		cprintf("**waiting for: %d \n ",pids[i]);
+		waitpid(pids[i], &status, BLOCKING);
+	}
+	*/
+
+	return retVal;
+}
+
+int
+set_priority(int priority)
+{
+#ifndef CFS
+	return -1;
+#endif
+	acquire(&ptable.lock);
+	proc->priority = priority;
+	release(&ptable.lock);
+	return 1;
+}
+
+// Filling process_info_entry array with <pid,name> that is not zombie and has required <gid>
+// should be called with a 64(=MAX NUM OF PROCESSES), will set <size> accordingly
+int
+list_pgroup(int gid, process_info_entry* arr, int* size)
+{
+	struct proc* p;
+	int i = 0;
+//	struct node* head;
+//
+//	linkedList plist;
+//	  init_linkedList(&plist, 64);
+//	  head = create_link(&plist);
+//	  head->id = 18;
+//	  head->data = 0;
+//
+//	  add_last(&plist,head);
+//	plist.print(&plist);
+	acquire(&ptable.lock);
+
+//	cprintf("10 entire from process table:\n");
+//
+//	cprintf("pid   name   gid   father   father_name   \n");
+//
+//	for(p = ptable.proc; p < &ptable.proc[10]; p++){
+//		cprintf("%d %d   %s   %d   %d   %s  \n", j, p->pid, p->name, p->gid,p->parent->pid,p->parent->name);
+//		j++;
+//	}
+
+//	cprintf("requested listing of processes with group id %d \n", gid);
+
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+		if( ( p->state == RUNNING ||  p->state == RUNNABLE ||  p->state == SLEEPING) &&
+			p->gid == gid ){
+
+			arr[i].pid = p->pid;
+			safestrcpy(arr[i].name, p->name, sizeof(arr[i].name));
+			i++;
+		}
+	}
+
+//	cprintf("found %d for group id %d  \n", i, gid);
+
+	*size = i;
+	release(&ptable.lock);
+
+	return 0;
+}
+
+
+#ifdef DEFAULT
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -263,7 +558,7 @@ wait(void)
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
 void
-scheduler(void)
+scheduler_default(void)
 {
   struct proc *p;
 
@@ -294,6 +589,116 @@ scheduler(void)
 
   }
 }
+#endif
+
+#if defined(FRR) || defined(FCFS)
+void
+scheduler_frr_fcfs(void)
+{
+	  struct proc *p;
+
+	  for(;;){
+	    // Enable interrupts on this processor.
+	    sti();
+
+	    acquire(&ptable.lock);
+	    if (plist.size)
+	    {
+			  p = plist.remove_first(&plist);
+			  if(p->state != RUNNABLE){
+				  cprintf("ERROR: linkedlist contains a proc which is not RUNNABLE");
+			  }
+
+			  // Switch to chosen process.  It is the process's job
+			  // to release ptable.lock and then reacquire it
+			  // before jumping back to us.
+			  proc = p;
+			  switchuvm(p);
+			  p->state = RUNNING;
+			  swtch(&cpu->scheduler, proc->context);
+			  switchkvm();
+
+			  // Process is done running for now.
+			  // It should have changed its p->state before coming back.
+			  proc = 0;
+	    }
+	    release(&ptable.lock);
+
+	  }
+	}
+#endif
+
+
+#ifdef CFS
+
+void
+scheduler_cfs(void)
+{
+  struct proc *p;
+  struct proc* minimum_vruntime_proc;
+
+
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+
+    minimum_vruntime_proc = 0;	//null
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)	continue;
+
+      if (!minimum_vruntime_proc || p->vruntime < minimum_vruntime_proc->vruntime){
+    	  minimum_vruntime_proc = p;
+      }
+
+    }
+    p = minimum_vruntime_proc;
+    if (p)
+    {
+    	//cprintf("[%d:%d]", p->pid, p->vruntime);
+		// Switch to chosen process.  It is the process's job
+		// to release ptable.lock and then reacquire it
+		// before jumping back to us.
+		proc = p;
+		switchuvm(p);
+		p->state = RUNNING;
+		swtch(&cpu->scheduler, proc->context);
+		switchkvm();
+
+		// Process is done running for now.
+		// It should have changed its p->state before coming back.
+		proc = 0;
+    }
+
+    release(&ptable.lock);
+
+  }
+}
+
+#endif
+
+
+void
+scheduler(void)
+{
+	#if FRR
+		cprintf("SCHEDULAR = FRR\n");
+		scheduler_frr_fcfs();
+	#elif FCFS
+		cprintf("SCHEDULAR = FCFS\n");
+		scheduler_frr_fcfs();
+	#elif CFS
+		cprintf("SCHEDULAR = CFS\n");
+		scheduler_cfs();
+	#else
+		cprintf("SCHEDULAR = DEFAULT\n");
+		scheduler_default();
+	#endif
+
+	for(;;){}	//must be no-return
+}
 
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
@@ -320,7 +725,11 @@ void
 yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
+#if defined(FRR) || defined(FCFS)
+  if(proc->state != RUNNABLE) plist.add(&plist, proc->pid, proc); //todo ifdef
+#endif
   proc->state = RUNNABLE;
+
   sched();
   release(&ptable.lock);
 }
@@ -391,8 +800,12 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    if(p->state == SLEEPING && p->chan == chan){
+        p->state = RUNNABLE;
+		#if defined(FRR) || defined(FCFS)
+        	plist.add(&plist,p->pid, p);
+		#endif
+    }
 }
 
 // Wake up all processes sleeping on chan.
@@ -417,8 +830,12 @@ kill(int pid)
     if(p->pid == pid){
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if(p->state == SLEEPING){
         p->state = RUNNABLE;
+		#if defined(FRR) || defined(FCFS)
+        	plist.add(&plist,p->pid,p);
+		#endif
+      }
       release(&ptable.lock);
       return 0;
     }
diff --git a/proc.h b/proc.h
index 3b9c3ac..a37b0a2 100644
--- a/proc.h
+++ b/proc.h
@@ -58,6 +58,7 @@ struct proc {
   char *kstack;                // Bottom of kernel stack for this process
   enum procstate state;        // Process state
   int pid;                     // Process ID
+  int gid;						// Process group id
   struct proc *parent;         // Parent process
   struct trapframe *tf;        // Trap frame for current syscall
   struct context *context;     // swtch() here to run process
@@ -66,6 +67,14 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int status;				   // Exit status
+  int ctime;					//Creation time
+  int ttime;					//Termination time
+  int stime;					//Sleeping (IO) time
+  int retime;					// Ready (Runnable) time
+  int rutime;					// Running time
+  int priority;					// Priority
+  int vruntime;					//Higher value means lower current priority
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/read.c b/read.c
new file mode 100644
index 0000000..6cc94de
--- /dev/null
+++ b/read.c
@@ -0,0 +1,23 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char *argv[])
+{
+	char c[2] = {0,0};
+	int pos = 0;
+
+	while(1){
+		read(0,&c[pos],1);
+		write(1,&c[pos],1);
+
+		if(c[pos] == '\n' && c[!pos] == 'q'){
+			exit(0);
+		}
+
+		pos = !pos;
+
+	}
+	return 0;
+}
diff --git a/rm.c b/rm.c
index 4fd33c8..2bdc752 100644
--- a/rm.c
+++ b/rm.c
@@ -9,7 +9,7 @@ main(int argc, char *argv[])
 
   if(argc < 2){
     printf(2, "Usage: rm files...\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 1; i < argc; i++){
@@ -19,5 +19,5 @@ main(int argc, char *argv[])
     }
   }
 
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/runoff b/runoff
new file mode 100755
index 0000000..26593af
--- /dev/null
+++ b/runoff
@@ -0,0 +1,243 @@
+#!/bin/sh
+
+echo This script takes a minute to run.  Be patient. 1>&2
+
+LC_CTYPE=C export LC_CTYPE
+
+# pad stdin to multiple of 120 lines
+pad()
+{
+	awk '{print} END{for(; NR%120!=0; NR++) print ""}'
+}
+
+# create formatted (numbered) files
+mkdir -p fmt
+rm -f fmt/*
+cp README fmt
+files=`grep -v '^#' runoff.list | awk '{print $1}'`
+n=99
+for i in $files
+do
+	./runoff1 -n $n $i >fmt/$i
+	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
+	if [ "x$nn" != x ]; then
+		n=$nn
+	fi
+done
+
+# create table of contents
+cat toc.hdr >fmt/toc
+pr -e8 -t runoff.list | awk '
+/^[a-z0-9]/ {
+	s=$0
+	f="fmt/"$1
+	getline<f
+	close(f)
+	n=$1
+	printf("%02d %s\n", n/100, s);
+	printf("TOC: %04d %s\n", n, s) >"fmt/tocdata"
+	next
+}
+{
+	print
+}' | pr -3 -t >>fmt/toc
+cat toc.ftr >>fmt/toc
+
+# check for bad alignments
+perl -e '
+	$leftwarn = 0;
+	while(<>){
+		chomp;
+		s!#.*!!;
+		s!\s+! !g;
+		s! +$!!;
+		next if /^$/;
+		
+		if(/TOC: (\d+) (.*)/){
+			$toc{$2} = $1;
+			next;
+		}
+		
+		if(/sheet1: (left|right)$/){
+			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
+			$left = $1 eq "left" ? "13579" : "02468";
+			$right = $1 eq "left" ? "02468" : "13579";
+			next;
+		}
+		
+		if(/even: (.*)/){
+			$file = $1;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($toc{$file} =~ /^\d\d[^0]/){
+				print STDERR "$file does not start on a fresh page.\n";
+			}
+			next;
+		}
+		
+		if(/odd: (.*)/){
+			$file = $1;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($toc{$file} !~ /^\d\d5/){
+				print STDERR "$file does not start on a second half page.\n";
+			}
+			next;
+		}
+		
+		if(/(left|right): (.*)/){
+			$what = $1;
+			$file = $2;
+			if(!defined($toc{$file})){
+				print STDERR "Have no toc for $file\n";
+				next;
+			}
+			if($what eq "left" && !($toc{$file} =~ /^\d[$left][05]/)){
+				print STDERR "$file does not start on a left page [$toc{$file}]\n";
+			}
+			# why does this not work if I inline $x in the if?
+			$x = ($toc{$file} =~ /^\d[$right][05]/);
+			if($what eq "right" && !$x){
+				print STDERR "$file does not start on a right page [$toc{$file}] [$x]\n";
+			}
+			next;
+		}
+		
+		print STDERR "Unknown spec: $_\n";
+	}
+' fmt/tocdata runoff.spec
+
+# make definition list
+cd fmt
+perl -e '
+	while(<>) {
+		chomp;
+
+		s!//.*!!;
+		s!/\*([^*]|[*][^/])*\*/!!g;
+		s!\s! !g;
+		s! +$!!;
+
+		# look for declarations like char* x;
+		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
+			next;
+		}
+		if (/^[0-9]+ extern/) {
+			next;
+		}
+		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
+			next;
+		}
+		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
+			print "$1 $2\n"
+		}
+		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
+			print "$1 $2 $3\n";
+		}
+		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
+			print "$1 $2\n";
+		}
+		
+		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
+			$isglobl{$2} = 1;
+		}
+		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
+			print "$1 $2\n";
+		}
+		
+		if (/\(/) {
+			next;
+		}
+
+		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
+			print "$1 $7\n";
+		}
+		
+		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
+			print "$1 $3\n";
+		}
+		# TODO: enum members
+	}
+' $files >defs
+
+(for i in $files
+do
+	case "$i" in
+	*.S)
+		cat $i | sed 's;#.*;;; s;//.*;;;'
+		;;
+	*)
+		cat $i | sed 's;//.*;;; s;"([^"\\]|\\.)*";;;'
+	esac
+done
+) >alltext
+
+perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
+	egrep -v ' (STUB|usage|main|if|for)$' >>defs
+#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
+#	>>defs
+(
+>s.defs
+
+# make reference list
+for i in `awk '{print $2}' defs | sort -f | uniq`
+do
+	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
+	echo $i $defs >>s.defs
+	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
+	if [ "x$defs" != "x$uses" ]; then
+		echo $i $defs
+		echo $uses |fmt -29 | sed 's/^/    /'
+#	else
+#		echo $i defined but not used >&2
+	fi
+done
+) >refs
+
+# build defs list
+awk '
+{
+	printf("%04d %s\n", $2, $1);
+	for(i=3; i<=NF; i++)
+		printf("%04d    \" \n", $i);
+}
+' s.defs > t.defs
+
+# format the whole thing
+(
+	../pr.pl README
+	../pr.pl -h "table of contents" toc
+	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
+	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
+	# pr.pl -h "definitions" -2 t.defs | pad
+	# pr.pl -h "cross-references" -2 refs | pad 
+	for i in $files
+	do
+		../pr.pl -h "xv6/$i" $i
+	done
+) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
+grep Pages: all.ps
+
+# if we have the nice font, use it
+nicefont=LucidaSans-Typewriter83
+if [ ! -f ../$nicefont ]
+then
+	if git cat-file blob font:$nicefont > ../$nicefont~; then
+		mv ../$nicefont~ ../$nicefont
+	fi
+fi
+if [ -f ../$nicefont ]
+then
+	echo nicefont
+	(sed 1q all.ps; cat ../$nicefont; sed "1d; s/Courier/$nicefont/" all.ps) >allf.ps
+else
+	echo ugly font!
+	cp all.ps allf.ps
+fi
+ps2pdf allf.ps ../xv6.pdf
+# cd ..
+# pdftops xv6.pdf xv6.ps
diff --git a/runoff.list b/runoff.list
new file mode 100644
index 0000000..73d39f7
--- /dev/null
+++ b/runoff.list
@@ -0,0 +1,77 @@
+# basic headers
+types.h
+param.h
+memlayout.h
+defs.h
+x86.h
+asm.h
+mmu.h
+elf.h
+
+# entering xv6
+entry.S
+entryother.S
+main.c
+
+# locks
+spinlock.h
+spinlock.c
+
+# processes
+vm.c
+proc.h
+proc.c
+swtch.S
+kalloc.c
+
+# system calls
+traps.h
+vectors.pl
+trapasm.S
+trap.c
+syscall.h
+syscall.c
+sysproc.c
+
+# file system
+buf.h
+fcntl.h
+stat.h
+fs.h
+file.h
+ide.c
+bio.c
+log.c
+fs.c
+file.c
+sysfile.c
+exec.c
+
+# pipes
+pipe.c
+
+# string operations
+string.c
+
+# low-level hardware
+mp.h
+mp.c
+lapic.c
+ioapic.c
+picirq.c
+kbd.h
+kbd.c
+console.c
+timer.c
+uart.c
+
+# user-level
+initcode.S
+usys.S
+init.c
+sh.c
+
+# bootloader
+bootasm.S
+bootmain.c
+
diff --git a/runoff.spec b/runoff.spec
new file mode 100644
index 0000000..9247948
--- /dev/null
+++ b/runoff.spec
@@ -0,0 +1,102 @@
+# Is sheet 01 (after the TOC) a left sheet or a right sheet?
+sheet1: left
+
+# "left" and "right" specify which page of a two-page spread a file
+# must start on.  "left" means that a file must start on the first of
+# the two pages.  "right" means it must start on the second of the two
+# pages.  The file may start in either column.
+#
+# "even" and "odd" specify which column a file must start on.  "even"
+# means it must start in the left of the two columns (00).  "odd" means it
+# must start in the right of the two columns (50).
+#
+# You'd think these would be the other way around.
+
+# types.h either
+# param.h either
+# defs.h either
+# x86.h either
+# asm.h either
+# mmu.h either
+# elf.h either
+# mp.h either
+
+even: entry.S  # mild preference
+even: entryother.S  # mild preference
+even: main.c
+# mp.c don't care at all
+# even: initcode.S
+# odd: init.c
+
+left: spinlock.h
+even: spinlock.h
+
+# This gets struct proc and allocproc on the same spread
+left: proc.h
+even: proc.h
+
+# goal is to have two action-packed 2-page spreads,
+# one with
+#     userinit growproc fork exit wait
+# and another with
+#     scheduler sched yield forkret sleep wakeup1 wakeup
+right: proc.c   # VERY important
+even: proc.c   # VERY important
+
+# A few more action packed spreads
+# page table creation and process loading
+#     walkpgdir mappages setupkvm switch[ku]vm inituvm (loaduvm)
+# process memory management
+#     allocuvm deallocuvm freevm
+left: vm.c
+
+even: kalloc.c  # mild preference
+
+# syscall.h either
+# trapasm.S either
+# traps.h either
+# even: trap.c
+# vectors.pl either
+# syscall.c either
+# sysproc.c either
+
+# buf.h either
+# dev.h either
+# fcntl.h either
+# stat.h either
+# file.h either
+# fs.h either
+# fsvar.h either
+# left: ide.c # mild preference
+even: ide.c
+# odd: bio.c
+
+# log.c fits nicely in a spread
+even: log.c
+left: log.c
+
+# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
+#	ialloc iupdate iget idup ilock iunlock iput iunlockput
+#	bmap itrunc stati readi writei
+#	namecmp dirlookup dirlink skipelem namex namei
+#	fileinit filealloc filedup fileclose filestat fileread filewrite
+# starting on 2nd column of a right page is not terrible either
+odd: fs.c   # VERY important
+left: fs.c  # mild preference
+# file.c either
+# exec.c either
+# sysfile.c either
+
+# Mild preference, but makes spreads of mp.c, lapic.c, and ioapic.c+picirq.c
+even: mp.c
+left: mp.c
+
+# even: pipe.c  # mild preference
+# string.c either
+# left: kbd.h  # mild preference
+even: kbd.h
+even: console.c
+odd: sh.c
+
+even: bootasm.S   # mild preference
+even: bootmain.c  # mild preference
diff --git a/runoff1 b/runoff1
new file mode 100755
index 0000000..532f844
--- /dev/null
+++ b/runoff1
@@ -0,0 +1,108 @@
+#!/usr/bin/perl
+
+$n = 0;
+$v = 0;
+if($ARGV[0] eq "-v") {
+	$v = 1;
+	shift @ARGV;
+}
+if($ARGV[0] eq "-n") {
+	$n = $ARGV[1];
+	shift @ARGV;
+	shift @ARGV;
+}
+$n = int(($n+49)/50)*50 - 1;
+
+$file = $ARGV[0];
+@lines = <>;
+$linenum = 0;
+foreach (@lines) {
+	$linenum++;
+	chomp;
+	s/\s+$//;
+	if(length() >= 75){
+		print STDERR "$file:$linenum: line too long\n";
+	}
+}
+@outlines = ();
+$nextout = 0;
+
+for($i=0; $i<@lines; ){
+	# Skip leading blank lines.
+	$i++ while $i<@lines && $lines[$i] =~ /^$/;
+	last if $i>=@lines;
+
+	# If the rest of the file fits, use the whole thing.
+	if(@lines <= $i+50 && !grep { /PAGEBREAK/ } @lines){
+		$breakbefore = @lines;
+	}else{
+		# Find a good next page break;
+		# Hope for end of function.
+		# but settle for a blank line (but not first blank line
+		# in function, which comes after variable declarations).
+		$breakbefore = $i;
+		$lastblank = $i;
+		$sawbrace = 0;
+		$breaksize = 15;  # 15 lines to get to function
+		for($j=$i; $j<$i+50 && $j < @lines; $j++){
+			if($lines[$j] =~ /PAGEBREAK!/){
+				$lines[$j] = "";
+				$breakbefore = $j;
+				$breaksize = 100;
+				last;
+			}
+			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
+				$breaksize = $1;
+				$breakbefore = $j;
+				$lines[$j] = "";
+			}
+			if($lines[$j] =~ /^};?$/){
+				$breakbefore = $j+1;
+				$breaksize = 15;
+			}
+			if($lines[$j] =~ /^{$/){
+				$sawbrace = 1;
+			}
+			if($lines[$j] =~ /^$/){
+				if($sawbrace){
+					$sawbrace = 0;
+				}else{
+					$lastblank = $j;
+				}
+			}
+		}
+		if($j<@lines && $lines[$j] =~ /^$/){
+			$lastblank = $j;
+		}
+
+		# If we are not putting enough on a page, try a blank line.
+		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
+			if($v){
+				print STDERR "breakbefore $breakbefore i $i breaksize $breaksize\n";
+			}
+			$breakbefore = $lastblank;
+			$breaksize = 5;  # only 5 lines to get to blank line
+		}
+
+		# If we are not putting enough on a page, force a full page.
+		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
+			$breakbefore = $i + 50;
+			$breakbefore = @lines if @lines < $breakbefore;
+		}
+
+		if($breakbefore < $i+2){
+			$breakbefore = $i+2;
+		}
+	}
+
+	# Emit the page.
+	$i50 = $i + 50;
+	for(; $i<$breakbefore; $i++){
+		printf "%04d %s\n", ++$n, $lines[$i];
+	}
+
+	# Finish page
+	for($j=$i; $j<$i50; $j++){
+		printf "%04d \n", ++$n;
+	}
+}
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..04fc753
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,83 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define NUM_OF_CHLIDREN 20
+#define CALC_SIZE		3000	//8000 is 1min for 1 proc in Ami's laptop
+
+
+long getTheNPrimeNumber(int n)
+{
+	long i=2;
+	long j;
+	int isPrime = 1;
+
+	for (;;) {
+		for (j = 2; j < i && isPrime; ++j) {
+			if (i%j == 0){
+				isPrime = 0;
+				break;
+			}
+		}
+		if (isPrime && ((n--)==1))	return i;
+		i++;
+		isPrime=1;
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	int i, pid, status;
+	int sum_wtime = 0, sum_rtime = 0, sum_iotime = 0;
+	int wtime, rtime, iotime;
+	int presence[NUM_OF_CHLIDREN];
+
+	set_priority(PRIORITY_HIGH);
+	memset(presence,0,NUM_OF_CHLIDREN);
+
+	printf(1, "NUM_OF_CHLIDREN=%d CALC_SIZE=%d\n",NUM_OF_CHLIDREN, CALC_SIZE);
+
+
+	for (i = 0; i < NUM_OF_CHLIDREN; ++i) {
+		if ((pid = fork()) > 0){	//parent
+			printf(1, "(fork:%d)",pid);
+		}
+		else if (pid == 0){	//child
+			set_priority((i%3)+1);
+			getTheNPrimeNumber(CALC_SIZE);
+			exit(getpid());
+		}
+		else{
+			printf(1, "\nERROR: Fork failed\n");
+			exit(EXIT_STATUS_FAILURE);
+		}
+	}
+	printf(1,"\n");
+
+	for (i = 0; i < NUM_OF_CHLIDREN; ++i){
+		//status returned should be pid
+		pid = wait_stat(&wtime,&rtime,&iotime,&status);
+		if (pid<0){
+			printf(1, "\nERROR: Not enought waits.\n");
+			exit(EXIT_STATUS_FAILURE);
+		}
+		sum_wtime  += wtime;
+		sum_rtime  += rtime;
+		sum_iotime += iotime;
+		printf(1,"Done(%d): waiting (RUNNABLE): %d | running: %d | turnaround : %d\n",
+				status, wtime, rtime, wtime+rtime+iotime);
+		presence[i] = status;
+	}
+
+	for (i = 0; i < NUM_OF_CHLIDREN; ++i){
+		if(!presence[i]){
+			printf(1, "\nERROR: Not enough waits.\n");
+			exit(EXIT_STATUS_FAILURE);
+		}
+	}
+	printf(1,"Averages: waiting (RUNNABLE): %d | running: %d | turnaround : %d\n",
+	       sum_wtime/NUM_OF_CHLIDREN, sum_rtime/NUM_OF_CHLIDREN, (sum_wtime+sum_rtime+sum_iotime)/NUM_OF_CHLIDREN);
+	printf(1, "Success: Great Success!.\n");
+	exit(EXIT_STATUS_SUCCESS);
+}
diff --git a/sh.c b/sh.c
index 16e325b..96ded2a 100644
--- a/sh.c
+++ b/sh.c
@@ -10,9 +10,21 @@
 #define PIPE  3
 #define LIST  4
 #define BACK  5
+#define JOBS  6
 
 #define MAXARGS 10
 
+struct job {
+  int num;
+  char cmd[100];
+  int gid;
+  int active;
+};
+
+static struct job jobs_table[1024];
+static int jobs_counter = 0;
+
+
 struct cmd {
   int type;
 };
@@ -53,11 +65,19 @@ int fork1(void);  // Fork but panics on failure.
 void panic(char*);
 struct cmd *parsecmd(char*);
 
+//copies string without \n
+void copyString(char* dst, char* src){
+	int i = 0;
+	while(src[i] != 0 && src[i] != '\n'){
+		dst[i] = src[i];
+		i++;
+	}
+}
 // Execute cmd.  Never returns.
 void
 runcmd(struct cmd *cmd)
 {
-  int p[2];
+  int p[2], left, right;
   struct backcmd *bcmd;
   struct execcmd *ecmd;
   struct listcmd *lcmd;
@@ -65,7 +85,7 @@ runcmd(struct cmd *cmd)
   struct redircmd *rcmd;
 
   if(cmd == 0)
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   
   switch(cmd->type){
   default:
@@ -74,7 +94,7 @@ runcmd(struct cmd *cmd)
   case EXEC:
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
@@ -84,7 +104,7 @@ runcmd(struct cmd *cmd)
     close(rcmd->fd);
     if(open(rcmd->file, rcmd->mode) < 0){
       printf(2, "open %s failed\n", rcmd->file);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     runcmd(rcmd->cmd);
     break;
@@ -93,7 +113,7 @@ runcmd(struct cmd *cmd)
     lcmd = (struct listcmd*)cmd;
     if(fork1() == 0)
       runcmd(lcmd->left);
-    wait();
+    wait(0);
     runcmd(lcmd->right);
     break;
 
@@ -101,14 +121,16 @@ runcmd(struct cmd *cmd)
     pcmd = (struct pipecmd*)cmd;
     if(pipe(p) < 0)
       panic("pipe");
-    if(fork1() == 0){
+
+    if( (left = fork1()) == 0){
       close(1);
       dup(p[1]);
       close(p[0]);
       close(p[1]);
       runcmd(pcmd->left);
     }
-    if(fork1() == 0){
+
+    if( (right = fork1() ) == 0){
       close(0);
       dup(p[0]);
       close(p[0]);
@@ -117,8 +139,8 @@ runcmd(struct cmd *cmd)
     }
     close(p[0]);
     close(p[1]);
-    wait();
-    wait();
+    wait(0);
+    wait(0);
     break;
     
   case BACK:
@@ -127,7 +149,7 @@ runcmd(struct cmd *cmd)
       runcmd(bcmd->cmd);
     break;
   }
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
 
 int
@@ -141,12 +163,86 @@ getcmd(char *buf, int nbuf)
   return 0;
 }
 
+void listJobs(){
+	int i,j;
+	int size;
+	int hasJobs = 0;
+	process_info_entry arr[64];
+
+	for(i=0; i< jobs_counter; i++){
+		if(jobs_table[i].active){
+			list_pgroup(jobs_table[i].gid, arr, &size);
+			if( size > 0){
+				hasJobs = 1;
+				printf(1,"Job %d: %s (%d) \n", i, jobs_table[i].cmd, jobs_table[i].gid);
+				for(j=0; j< size; j++){
+					printf(1,"%d: %s \n", arr[j].pid, arr[j].name);
+				}
+			}
+			else{
+				jobs_table[i].active = 0;
+			}
+		}
+	}
+	if(!hasJobs){
+		printf(1, "There are no jobs\n");
+	}
+}
+
+int move_to_foreground(int job_id){
+	int i;//, desired_job_idx;
+	int fgRet = -1;
+	//printf(1," asked to fg %d \n", job_id);
+
+	if(job_id == -1){
+		for (i = 0; i < jobs_counter; i++) {
+			if( jobs_table[i].active){
+				fgRet = foreground(jobs_table[i].gid);
+				jobs_table[i].active = 0;
+				if (fgRet != -1) return 0;
+			}
+		}
+	}
+	else if( jobs_table[job_id].active){
+		foreground(jobs_table[job_id].gid);
+		jobs_table[job_id].active = 0;
+		return 0;
+	}
+
+	return -1;
+}
+//	if(job_id == -1){
+//		for (i = 0; i < !found && jobs_counter; i++) {
+//			if( jobs_table[i].active){
+//				job_id = i;
+//				found = 1;
+//				break;
+//			}
+//		}
+//	}
+
+//	if(job_id != -1 && jobs_table[job_id].active ){
+//		while(  ret != -1){
+//			ret = foreground(jobs_table[i].gid);
+//		};
+//		foreground(jobs_table[i].gid);
+//		found = 1;
+////	}
+//
+//	printf(1," asta la vista babe ;\n");
+//	return (found? 0 : -1);
+//}
 int
 main(void)
 {
   static char buf[100];
   int fd;
+  int child_pid;
+  int job_id;
   
+  jobs_table[0].active = 0;
+  if(jobs_table[0].active) printf(1, " just so it wont cry on unused");
+
   // Assumes three file descriptors open.
   while((fd = open("console", O_RDWR)) >= 0){
     if(fd >= 3){
@@ -165,18 +261,44 @@ main(void)
         printf(2, "cannot cd %s\n", buf+3);
       continue;
     }
-    if(fork1() == 0)
-      runcmd(parsecmd(buf));
-    wait();
+
+    if(buf[0] == 'j' && buf[1] == 'o' && buf[2] == 'b' && buf[3] == 's' && buf[4] == '\n'){
+      listJobs();
+	  continue;
+	}
+
+    if(buf[0] == 'f' && buf[1] == 'g' ){
+		if( buf[2] == '\n' ){
+			job_id = -1;
+		}
+		else if( buf[2] == ' ' ){
+			job_id = atoi(buf+3);
+		}
+
+		move_to_foreground(job_id);
+		continue;
+	}
+
+    if((child_pid = fork1()) == 0){
+        runcmd(parsecmd(buf));
+    }
+    //keep track on jobs
+    jobs_table[jobs_counter].gid = child_pid;
+    jobs_table[jobs_counter].num = jobs_counter;
+    jobs_table[jobs_counter].active = 1;
+    copyString(jobs_table[jobs_counter].cmd, buf);
+	jobs_counter++;
+
+    wait(0);
   }
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
 
 void
 panic(char *s)
 {
   printf(2, "%s\n", s);
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
 
 int
diff --git a/show1 b/show1
new file mode 100755
index 0000000..e0d3d83
--- /dev/null
+++ b/show1
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
diff --git a/sleep1.p b/sleep1.p
new file mode 100644
index 0000000..af69772
--- /dev/null
+++ b/sleep1.p
@@ -0,0 +1,134 @@
+/*
+This file defines a Promela model for xv6's
+acquire, release, sleep, and wakeup, along with
+a model of a simple producer/consumer queue.
+
+To run:
+	spinp sleep1.p
+
+(You may need to install Spin, available at http://spinroot.com/.)
+
+After a successful run spin prints something like:
+
+	unreached in proctype consumer
+		(0 of 37 states)
+	unreached in proctype producer
+		(0 of 23 states)
+
+After an unsuccessful run, the spinp script prints
+an execution trace that causes a deadlock.
+
+The safe body of producer reads:
+
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		wakeup(0);
+		release(lk);
+		i = i + 1;
+
+If this is changed to:
+
+		x = value; value = x + 1; x = 0;
+		acquire(lk);
+		wakeup(0);
+		release(lk);
+		i = i + 1;
+
+then a deadlock can happen, because the non-atomic
+increment of value conflicts with the non-atomic 
+decrement in consumer, causing value to have a bad value.
+Try this.
+
+If it is changed to:
+
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		release(lk);
+		wakeup(0);
+		i = i + 1;
+
+then nothing bad happens: it is okay to wakeup after release
+instead of before, although it seems morally wrong.
+*/
+
+#define ITER 4
+#define N 2
+
+bit lk;
+byte value;
+bit sleeping[N];
+
+inline acquire(x)
+{
+	atomic { x == 0; x = 1 }
+}
+
+inline release(x)
+{
+	assert x==1;
+	x = 0
+}
+
+inline sleep(cond, lk)
+{
+	assert !sleeping[_pid];
+	if
+	:: cond ->
+		skip
+	:: else ->
+		atomic { release(lk); sleeping[_pid] = 1 };
+		sleeping[_pid] == 0;
+		acquire(lk)
+	fi
+}
+
+inline wakeup()
+{
+	w = 0;
+	do
+	:: w < N ->
+		sleeping[w] = 0;
+		w = w + 1
+	:: else ->
+		break
+	od
+}
+
+active[N] proctype consumer()
+{
+	byte i, x;
+	
+	i = 0;
+	do
+	:: i < ITER ->
+		acquire(lk);
+		sleep(value > 0, lk);
+		x = value; value = x - 1; x = 0;
+		release(lk);
+		i = i + 1;
+	:: else ->
+		break
+	od;
+	i = 0;
+	skip
+}
+
+active[N] proctype producer()
+{
+	byte i, x, w;
+	
+	i = 0;
+	do
+	:: i < ITER ->
+		acquire(lk);
+		x = value; value = x + 1; x = 0;
+		release(lk);
+		wakeup();
+		i = i + 1;
+	:: else ->
+		break
+	od;
+	i = 0;
+	skip	
+}
+
diff --git a/spinp b/spinp
new file mode 100755
index 0000000..db9614b
--- /dev/null
+++ b/spinp
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+if [ $# != 1 ] || [ ! -f "$1" ]; then
+	echo 'usage: spinp file.p' 1>&2
+	exit 1
+fi
+
+rm -f $1.trail
+spin -a $1 || exit 1
+cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
+pan -i
+rm pan.* pan
+if [ -f $1.trail ]; then
+	spin -t -p $1
+fi
+
diff --git a/stat.h b/stat.h
index 8a80933..edc32f8 100644
--- a/stat.h
+++ b/stat.h
@@ -2,6 +2,7 @@
 #define T_FILE 2   // File
 #define T_DEV  3   // Device
 
+
 struct stat {
   short type;  // Type of file
   int dev;     // File system's disk device
diff --git a/stressfs.c b/stressfs.c
index 6369400..d573e72 100644
--- a/stressfs.c
+++ b/stressfs.c
@@ -43,7 +43,7 @@ main(int argc, char *argv[])
     read(fd, data, sizeof(data));
   close(fd);
 
-  wait();
+  wait(0);
   
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/symlink.patch b/symlink.patch
new file mode 100644
index 0000000..c7caf23
--- /dev/null
+++ b/symlink.patch
@@ -0,0 +1,151 @@
+diff -r f8a4e40ab1d6 fs.c
+--- a/fs.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.c	Thu Aug 30 14:29:02 2007 -0400
+@@ -577,12 +577,18 @@ skipelem(char *path, char *name)
+ // If parent != 0, return the inode for the parent and copy the final
+ // path element into name, which must have room for DIRSIZ bytes.
+ static struct inode*
+-_namei(char *path, int parent, char *name)
++_namei(struct inode *root, char *path, int parent, char *name, int depth)
+ {
+   struct inode *ip, *next;
++  char buf[100], tname[DIRSIZ];
++
++  if(depth > 5)
++    return 0;
+ 
+   if(*path == '/')
+     ip = iget(ROOTDEV, 1);
++  else if(root)
++    ip = idup(root);
+   else
+     ip = idup(cp->cwd);
+ 
+@@ -598,10 +604,24 @@ _namei(char *path, int parent, char *nam
+       return ip;
+     }
+     if((next = dirlookup(ip, name, 0)) == 0){
++      cprintf("did not find %s\n", name);
+       iunlockput(ip);
+       return 0;
+     }
+-    iunlockput(ip);
++    iunlock(ip);
++    ilock(next);
++    if(next->type == T_SYMLINK){
++      if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
++        iunlockput(next);
++        iput(ip);
++        return 0;
++      }
++      buf[next->size] = 0;
++      iunlockput(next);
++      next = _namei(ip, buf, 0, tname, depth+1);
++    }else
++      iunlock(next);
++    iput(ip);
+     ip = next;
+   }
+   if(parent){
+@@ -615,11 +635,11 @@ namei(char *path)
+ namei(char *path)
+ {
+   char name[DIRSIZ];
+-  return _namei(path, 0, name);
++  return _namei(0, path, 0, name, 0);
+ }
+ 
+ struct inode*
+ nameiparent(char *path, char *name)
+ {
+-  return _namei(path, 1, name);
+-}
++  return _namei(0, path, 1, name, 0);
++}
+diff -r f8a4e40ab1d6 fs.h
+--- a/fs.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/fs.h	Thu Aug 30 13:05:43 2007 -0400
+@@ -33,6 +33,7 @@ struct dinode {
+ #define T_DIR  1   // Directory
+ #define T_FILE 2   // File
+ #define T_DEV  3   // Special device
++#define T_SYMLINK 4  // Symlink
+ 
+ // Inodes per block.
+ #define IPB           (BSIZE / sizeof(struct dinode))
+diff -r f8a4e40ab1d6 syscall.c
+--- a/syscall.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.c	Thu Aug 30 13:05:29 2007 -0400
+@@ -96,6 +96,7 @@ extern int sys_unlink(void);
+ extern int sys_unlink(void);
+ extern int sys_wait(void);
+ extern int sys_write(void);
++extern int sys_symlink(void);
+ 
+ static int (*syscalls[])(void) = {
+ [SYS_chdir]   sys_chdir,
+@@ -118,6 +119,7 @@ static int (*syscalls[])(void) = {
+ [SYS_unlink]  sys_unlink,
+ [SYS_wait]    sys_wait,
+ [SYS_write]   sys_write,
++[SYS_symlink]	sys_symlink,
+ };
+ 
+ void
+diff -r f8a4e40ab1d6 syscall.h
+--- a/syscall.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/syscall.h	Thu Aug 30 13:02:48 2007 -0400
+@@ -19,3 +19,4 @@
+ #define SYS_getpid 18
+ #define SYS_sbrk   19
+ #define SYS_sleep  20
++#define SYS_symlink 21
+diff -r f8a4e40ab1d6 sysfile.c
+--- a/sysfile.c	Thu Aug 30 14:32:06 2007 -0400
++++ b/sysfile.c	Thu Aug 30 13:10:31 2007 -0400
+@@ -257,6 +257,21 @@ create(char *path, int canexist, short t
+ }
+ 
+ int
++sys_symlink(void)
++{
++  char *old, *new;
++  struct inode *ip;
++  
++  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
++    return -1;
++  if((ip = create(new, 0, T_SYMLINK, 0, 0)) == 0)
++    return -1;
++  writei(ip, old, 0, strlen(old));
++  iunlockput(ip);
++  return 0;
++}
++
++int
+ sys_open(void)
+ {
+   char *path;
+@@ -393,3 +408,4 @@ sys_pipe(void)
+   fd[1] = fd1;
+   return 0;
+ }
++
+diff -r f8a4e40ab1d6 user.h
+--- a/user.h	Thu Aug 30 14:32:06 2007 -0400
++++ b/user.h	Thu Aug 30 13:02:34 2007 -0400
+@@ -21,6 +21,7 @@ int getpid();
+ int getpid();
+ char* sbrk(int);
+ int sleep(int);
++int symlink(int);
+ 
+ // ulib.c
+ int stat(char*, struct stat*);
+diff -r f8a4e40ab1d6 usys.S
+--- a/usys.S	Thu Aug 30 14:32:06 2007 -0400
++++ b/usys.S	Thu Aug 30 13:05:54 2007 -0400
+@@ -28,3 +28,4 @@ STUB(getpid)
+ STUB(getpid)
+ STUB(sbrk)
+ STUB(sleep)
++STUB(symlink)
diff --git a/syscall.c b/syscall.c
index 799ebc2..699b2e1 100644
--- a/syscall.c
+++ b/syscall.c
@@ -96,8 +96,14 @@ extern int sys_sbrk(void);
 extern int sys_sleep(void);
 extern int sys_unlink(void);
 extern int sys_wait(void);
+extern int sys_waitpid(void);
+extern int sys_wait_stat(void);
+extern int sys_list_pgroup(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_foreground(void);
+extern int sys_set_priority(void);
+
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +127,11 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_waitpid]    sys_waitpid,
+[SYS_wait_stat]    sys_wait_stat,
+[SYS_list_pgroup]    sys_list_pgroup,
+[SYS_foreground]    sys_foreground,
+[SYS_set_priority]	sys_set_priority,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..63f53fe 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,9 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_waitpid   22
+#define SYS_wait_stat 23
+#define SYS_list_pgroup 24
+#define SYS_foreground 25
+#define SYS_set_priority 26
+
diff --git a/sysproc.c b/sysproc.c
index 027a5e5..5a5ce96 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -16,17 +16,99 @@ sys_fork(void)
 int
 sys_exit(void)
 {
-  exit();
-  return 0;  // not reached
+	int status;
+	if(argint(0, &status) < 0)
+	    return -1;
+
+	exit(status);
+	return 0;  // not reached
 }
 
 int
 sys_wait(void)
 {
-  return wait();
+	int* status;
+	//take argument from environment
+	if(argptr(0,(char**)&status, sizeof(int)) <0){ //error check
+		return -1;
+	}
+	return wait(status);
+}
+
+int
+sys_waitpid(void)
+{
+	int pid;
+	int *status;
+	int options;
+
+	if (	(argint(0, &pid) < 0) ||
+			(argptr(1,(char**)&status, sizeof(int)) < 0) ||
+			(argint(2, &options) < 0) ){
+
+		return -1;
+	}
+
+	return waitpid(pid, status, options);
+}
+
+int
+sys_wait_stat(void)
+{
+	int *wtime, *rtime, *iotime, *status;
+
+	if (	(argptr(0,(char**)&wtime, sizeof(int)) < 0) ||
+			(argptr(1,(char**)&rtime, sizeof(int)) < 0) ||
+			(argptr(2,(char**)&iotime, sizeof(int)) < 0) ||
+			(argptr(3,(char**)&status, sizeof(int)) < 0) ){
+
+		return -1;
+	}
+
+	return wait_stat(wtime, rtime, iotime, status);
+}
+
+int
+sys_list_pgroup(void)
+{
+	int gid;
+	process_info_entry* arr;
+	int* size;
+
+	if (	(argint(0, &gid) < 0) ||
+			(argptr(1,(char**)&arr, sizeof(process_info_entry)) < 0) ||
+			(argptr(2,(char**)&size, sizeof(int)) < 0)){
+
+		return -1;
+	}
+
+	return list_pgroup(gid, arr, size);
 }
 
 int
+sys_foreground(void)
+{
+	int gid;
+
+	if (argint(0, &gid) < 0){
+		return -1;
+	}
+
+	return foreground(gid);
+}
+
+int
+sys_set_priority(void)
+{
+	int priority;
+
+	if(argint(0, &priority) < 0)
+	return -1;
+	return set_priority(priority);
+}
+
+
+int
 sys_kill(void)
 {
   int pid;
diff --git a/toc.ftr b/toc.ftr
new file mode 100644
index 0000000..0061c1d
--- /dev/null
+++ b/toc.ftr
@@ -0,0 +1,13 @@
+
+
+The source listing is preceded by a cross-reference that lists every defined 
+constant, struct, global variable, and function in xv6.  Each entry gives,
+on the same line as the name, the line number (or, in a few cases, numbers)
+where the name is defined.  Successive lines in an entry list the line
+numbers where the name is used.  For example, this entry:
+
+    swtch 2658
+        0374 2428 2466 2657 2658
+
+indicates that swtch is defined on line 2658 and is mentioned on five lines
+on sheets 03, 24, and 26.
diff --git a/toc.hdr b/toc.hdr
new file mode 100644
index 0000000..3698d81
--- /dev/null
+++ b/toc.hdr
@@ -0,0 +1,6 @@
+The numbers to the left of the file names in the table are sheet numbers.
+The source code has been printed in a double column format with fifty
+lines per column, giving one hundred lines per sheet (or page).
+Thus there is a convenient relationship between line numbers and sheet numbers.
+
+
diff --git a/trap.c b/trap.c
index 3f80145..f092cb0 100644
--- a/trap.c
+++ b/trap.c
@@ -32,17 +32,44 @@ idtinit(void)
   lidt(idt, sizeof(idt));
 }
 
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+void updateStats()
+{
+	struct proc* p;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+		switch (p->state) {
+			case SLEEPING:
+				p->stime++;
+				break;
+			case RUNNABLE:
+				p->retime++;
+				break;
+			case RUNNING:
+				p->rutime++;
+				p->vruntime += p->priority;
+				break;
+			default:
+				break;
+		}
+    }
+}
+
+
 //PAGEBREAK: 41
 void
 trap(struct trapframe *tf)
 {
   if(tf->trapno == T_SYSCALL){
     if(proc->killed)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     proc->tf = tf;
     syscall();
     if(proc->killed)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     return;
   }
 
@@ -53,6 +80,8 @@ trap(struct trapframe *tf)
       ticks++;
       wakeup(&ticks);
       release(&tickslock);
+
+      updateStats();
     }
     lapiceoi();
     break;
@@ -98,14 +127,18 @@ trap(struct trapframe *tf)
   // (If it is still executing in the kernel, let it keep running 
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
 
-  // Force process to give up CPU on clock tick.
+//only for preemptive schedualing
+#ifndef FCFS //all policies are preemptive besides FCFS
+  // Force process to give up CPU on <QUANTA> clock tick.
   // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+	    if( !(ticks % QUANTA) ) yield();
+  }
+#endif
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/types.h b/types.h
index e4adf64..ca72d9b 100644
--- a/types.h
+++ b/types.h
@@ -1,4 +1,14 @@
+enum status { EXIT_STATUS_FAILURE, EXIT_STATUS_SUCCESS, EXIT_STATUS_DEFAULT };
+enum wait_options { BLOCKING, NONBLOCKING, WAIT_GROUP };
+enum priority { PRIORITY_NONE, PRIORITY_HIGH, PRIORITY_MEDIUM, PRIORITY_LOW };
+
+
 typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+typedef struct process_info_entry{
+  int pid;
+  char name[16];
+} process_info_entry;
diff --git a/user.h b/user.h
index f45b8d5..032f879 100644
--- a/user.h
+++ b/user.h
@@ -1,10 +1,11 @@
 struct stat;
 struct rtcdate;
 
+
 // system calls
 int fork(void);
-int exit(void) __attribute__((noreturn));
-int wait(void);
+int exit(int) __attribute__((noreturn));
+int wait(int*);
 int pipe(int*);
 int write(int, void*, int);
 int read(int, void*, int);
@@ -23,6 +24,12 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int waitpid(int, int*, int);
+int wait_stat(int*, int*, int*, int*);
+int list_pgroup(int, process_info_entry*, int*);
+int foreground(int);
+int set_priority(int);
+
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usertests.c b/usertests.c
index 22a7bfb..3b3189e 100644
--- a/usertests.c
+++ b/usertests.c
@@ -21,24 +21,24 @@ iputtest(void)
 
   if(mkdir("iputdir") < 0){
     printf(stdout, "mkdir failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("iputdir") < 0){
     printf(stdout, "chdir iputdir failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("../iputdir") < 0){
     printf(stdout, "unlink ../iputdir failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("/") < 0){
     printf(stdout, "chdir / failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(stdout, "iput test ok\n");
 }
 
-// does exit() call iput(p->cwd) in a transaction?
+// does exit(EXIT_STATUS_DEFAULT) call iput(p->cwd) in a transaction?
 void
 exitiputtest(void)
 {
@@ -49,24 +49,24 @@ exitiputtest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(pid == 0){
     if(mkdir("iputdir") < 0){
       printf(stdout, "mkdir failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(chdir("iputdir") < 0){
       printf(stdout, "child chdir failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(unlink("../iputdir") < 0){
       printf(stdout, "unlink ../iputdir failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
-  wait();
+  wait(0);
   printf(stdout, "exitiput test ok\n");
 }
 
@@ -89,27 +89,27 @@ openiputtest(void)
   printf(stdout, "openiput test\n");
   if(mkdir("oidir") < 0){
     printf(stdout, "mkdir oidir failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   pid = fork();
   if(pid < 0){
     printf(stdout, "fork failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(pid == 0){
     int fd = open("oidir", O_RDWR);
     if(fd >= 0){
       printf(stdout, "open directory for write succeeded\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   sleep(1);
   if(unlink("oidir") != 0){
     printf(stdout, "unlink failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
-  wait();
+  wait(0);
   printf(stdout, "openiput test ok\n");
 }
 
@@ -124,13 +124,13 @@ opentest(void)
   fd = open("echo", 0);
   if(fd < 0){
     printf(stdout, "open echo failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
   fd = open("doesnotexist", 0);
   if(fd >= 0){
     printf(stdout, "open doesnotexist succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(stdout, "open test ok\n");
 }
@@ -147,16 +147,16 @@ writetest(void)
     printf(stdout, "creat small succeeded; ok\n");
   } else {
     printf(stdout, "error: creat small failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   for(i = 0; i < 100; i++){
     if(write(fd, "aaaaaaaaaa", 10) != 10){
       printf(stdout, "error: write aa %d new file failed\n", i);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(write(fd, "bbbbbbbbbb", 10) != 10){
       printf(stdout, "error: write bb %d new file failed\n", i);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   printf(stdout, "writes ok\n");
@@ -166,20 +166,20 @@ writetest(void)
     printf(stdout, "open small succeeded ok\n");
   } else {
     printf(stdout, "error: open small failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   i = read(fd, buf, 2000);
   if(i == 2000){
     printf(stdout, "read succeeded ok\n");
   } else {
     printf(stdout, "read failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(unlink("small") < 0){
     printf(stdout, "unlink small failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(stdout, "small file test ok\n");
 }
@@ -194,14 +194,14 @@ writetest1(void)
   fd = open("big", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(stdout, "error: creat big failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 0; i < MAXFILE; i++){
     ((int*)buf)[0] = i;
     if(write(fd, buf, 512) != 512){
       printf(stdout, "error: write big file failed\n", i);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
@@ -210,7 +210,7 @@ writetest1(void)
   fd = open("big", O_RDONLY);
   if(fd < 0){
     printf(stdout, "error: open big failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   n = 0;
@@ -219,24 +219,24 @@ writetest1(void)
     if(i == 0){
       if(n == MAXFILE - 1){
         printf(stdout, "read only %d blocks from big", n);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       break;
     } else if(i != 512){
       printf(stdout, "read failed %d\n", i);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(((int*)buf)[0] != n){
       printf(stdout, "read content of block %d is %d\n",
              n, ((int*)buf)[0]);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     n++;
   }
   close(fd);
   if(unlink("big") < 0){
     printf(stdout, "unlink big failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(stdout, "big files ok\n");
 }
@@ -270,22 +270,22 @@ void dirtest(void)
 
   if(mkdir("dir0") < 0){
     printf(stdout, "mkdir failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(chdir("dir0") < 0){
     printf(stdout, "chdir dir0 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(chdir("..") < 0){
     printf(stdout, "chdir .. failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(unlink("dir0") < 0){
     printf(stdout, "unlink dir0 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(stdout, "mkdir test ok\n");
 }
@@ -296,7 +296,7 @@ exectest(void)
   printf(stdout, "exec test\n");
   if(exec("echo", echoargv) < 0){
     printf(stdout, "exec echo failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 }
 
@@ -310,7 +310,7 @@ pipe1(void)
 
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   pid = fork();
   seq = 0;
@@ -321,10 +321,10 @@ pipe1(void)
         buf[i] = seq++;
       if(write(fds[1], buf, 1033) != 1033){
         printf(1, "pipe1 oops 1\n");
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
     }
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   } else if(pid > 0){
     close(fds[1]);
     total = 0;
@@ -343,13 +343,13 @@ pipe1(void)
     }
     if(total != 5 * 1033){
       printf(1, "pipe1 oops 3 total %d\n", total);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     close(fds[0]);
-    wait();
+    wait(0);
   } else {
     printf(1, "fork() failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(1, "pipe1 ok\n");
 }
@@ -394,9 +394,9 @@ preempt(void)
   kill(pid2);
   kill(pid3);
   printf(1, "wait... ");
-  wait();
-  wait();
-  wait();
+  wait(0);
+  wait(0);
+  wait(0);
   printf(1, "preempt ok\n");
 }
 
@@ -413,12 +413,12 @@ exitwait(void)
       return;
     }
     if(pid){
-      if(wait() != pid){
+      if(wait(0) != pid){
         printf(1, "wait wrong pid\n");
         return;
       }
     } else {
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   printf(1, "exitwait ok\n");
@@ -447,13 +447,13 @@ mem(void)
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     free(m1);
     printf(1, "mem ok\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   } else {
-    wait();
+    wait(0);
   }
 }
 
@@ -484,9 +484,9 @@ sharedfd(void)
     }
   }
   if(pid == 0)
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   else
-    wait();
+    wait(0);
   close(fd);
   fd = open("sharedfd", 0);
   if(fd < 0){
@@ -508,7 +508,7 @@ sharedfd(void)
     printf(1, "sharedfd ok\n");
   } else {
     printf(1, "sharedfd oops %d %d\n", nc, np);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 }
 
@@ -530,29 +530,29 @@ fourfiles(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
 
     if(pid == 0){
       fd = open(fname, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "create failed\n");
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
           printf(1, "write failed %d\n", n);
-          exit();
+          exit(EXIT_STATUS_DEFAULT);
         }
       }
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait();
+    wait(0);
   }
 
   for(i = 0; i < 2; i++){
@@ -563,7 +563,7 @@ fourfiles(void)
       for(j = 0; j < n; j++){
         if(buf[j] != '0'+i){
           printf(1, "wrong char\n");
-          exit();
+          exit(EXIT_STATUS_DEFAULT);
         }
       }
       total += n;
@@ -571,7 +571,7 @@ fourfiles(void)
     close(fd);
     if(total != 12*500){
       printf(1, "wrong length %d\n", total);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     unlink(fname);
   }
@@ -593,7 +593,7 @@ createdelete(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
 
     if(pid == 0){
@@ -604,23 +604,23 @@ createdelete(void)
         fd = open(name, O_CREATE | O_RDWR);
         if(fd < 0){
           printf(1, "create failed\n");
-          exit();
+          exit(EXIT_STATUS_DEFAULT);
         }
         close(fd);
         if(i > 0 && (i % 2 ) == 0){
           name[1] = '0' + (i / 2);
           if(unlink(name) < 0){
             printf(1, "unlink failed\n");
-            exit();
+            exit(EXIT_STATUS_DEFAULT);
           }
         }
       }
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
   for(pi = 0; pi < 4; pi++){
-    wait();
+    wait(0);
   }
 
   name[0] = name[1] = name[2] = 0;
@@ -631,10 +631,10 @@ createdelete(void)
       fd = open(name, 0);
       if((i == 0 || i >= N/2) && fd < 0){
         printf(1, "oops createdelete %s didn't exist\n", name);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       } else if((i >= 1 && i < N/2) && fd >= 0){
         printf(1, "oops createdelete %s did exist\n", name);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       if(fd >= 0)
         close(fd);
@@ -662,7 +662,7 @@ unlinkread(void)
   fd = open("unlinkread", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create unlinkread failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   write(fd, "hello", 5);
   close(fd);
@@ -670,11 +670,11 @@ unlinkread(void)
   fd = open("unlinkread", O_RDWR);
   if(fd < 0){
     printf(1, "open unlinkread failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("unlinkread") != 0){
     printf(1, "unlink unlinkread failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd1 = open("unlinkread", O_CREATE | O_RDWR);
@@ -683,15 +683,15 @@ unlinkread(void)
 
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "unlinkread read failed");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(buf[0] != 'h'){
     printf(1, "unlinkread wrong data\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(write(fd, buf, 10) != 10){
     printf(1, "unlinkread write failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
   unlink("unlinkread");
@@ -711,50 +711,50 @@ linktest(void)
   fd = open("lf1", O_CREATE|O_RDWR);
   if(fd < 0){
     printf(1, "create lf1 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(write(fd, "hello", 5) != 5){
     printf(1, "write lf1 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(link("lf1", "lf2") < 0){
     printf(1, "link lf1 lf2 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   unlink("lf1");
 
   if(open("lf1", 0) >= 0){
     printf(1, "unlinked lf1 but it is still there!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd = open("lf2", 0);
   if(fd < 0){
     printf(1, "open lf2 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(read(fd, buf, sizeof(buf)) != 5){
     printf(1, "read lf2 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(link("lf2", "lf2") >= 0){
     printf(1, "link lf2 lf2 succeeded! oops\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   unlink("lf2");
   if(link("lf2", "lf1") >= 0){
     printf(1, "link non-existant succeeded! oops\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(link(".", "lf1") >= 0){
     printf(1, "link . lf1 succeeded! oops\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   printf(1, "linktest ok\n");
@@ -787,14 +787,14 @@ concreate(void)
       fd = open(file, O_CREATE | O_RDWR);
       if(fd < 0){
         printf(1, "concreate create %s failed\n", file);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       close(fd);
     }
     if(pid == 0)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     else
-      wait();
+      wait(0);
   }
 
   memset(fa, 0, sizeof(fa));
@@ -807,11 +807,11 @@ concreate(void)
       i = de.name[1] - '0';
       if(i < 0 || i >= sizeof(fa)){
         printf(1, "concreate weird file %s\n", de.name);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       if(fa[i]){
         printf(1, "concreate duplicate file %s\n", de.name);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
       fa[i] = 1;
       n++;
@@ -821,7 +821,7 @@ concreate(void)
 
   if(n != 40){
     printf(1, "concreate not enough files in directory listing\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 0; i < 40; i++){
@@ -829,7 +829,7 @@ concreate(void)
     pid = fork();
     if(pid < 0){
       printf(1, "fork failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(((i % 3) == 0 && pid == 0) ||
        ((i % 3) == 1 && pid != 0)){
@@ -844,9 +844,9 @@ concreate(void)
       unlink(file);
     }
     if(pid == 0)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     else
-      wait();
+      wait(0);
   }
 
   printf(1, "concreate ok\n");
@@ -865,7 +865,7 @@ linkunlink()
   pid = fork();
   if(pid < 0){
     printf(1, "fork failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   unsigned int x = (pid ? 1 : 97);
@@ -881,9 +881,9 @@ linkunlink()
   }
 
   if(pid)
-    wait();
+    wait(0);
   else 
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
 
   printf(1, "linkunlink ok\n");
 }
@@ -901,7 +901,7 @@ bigdir(void)
   fd = open("bd", O_CREATE);
   if(fd < 0){
     printf(1, "bigdir create failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
@@ -912,7 +912,7 @@ bigdir(void)
     name[3] = '\0';
     if(link("bd", name) != 0){
       printf(1, "bigdir link failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
@@ -924,7 +924,7 @@ bigdir(void)
     name[3] = '\0';
     if(unlink(name) != 0){
       printf(1, "bigdir unlink failed");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
@@ -941,31 +941,31 @@ subdir(void)
   unlink("ff");
   if(mkdir("dd") != 0){
     printf(1, "subdir mkdir dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   write(fd, "ff", 2);
   close(fd);
   
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(mkdir("/dd/dd") != 0){
     printf(1, "subdir mkdir dd/dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "create dd/dd/ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   write(fd, "FF", 2);
   close(fd);
@@ -973,142 +973,142 @@ subdir(void)
   fd = open("dd/dd/../ff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/../ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   cc = read(fd, buf, sizeof(buf));
   if(cc != 2 || buf[0] != 'f'){
     printf(1, "dd/dd/../ff wrong content\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(link("dd/dd/ff", "dd/dd/ffff") != 0){
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(unlink("dd/dd/ff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(chdir("dd") != 0){
     printf(1, "chdir dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("dd/../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("dd/../../../dd") != 0){
     printf(1, "chdir dd/../../dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("./..") != 0){
     printf(1, "chdir ./.. failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd = open("dd/dd/ffff", 0);
   if(fd < 0){
     printf(1, "open dd/dd/ffff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(read(fd, buf, sizeof(buf)) != 2){
     printf(1, "read dd/dd/ffff wrong len\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(open("dd/dd/ff", O_RDONLY) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/ff/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
     printf(1, "create dd/xx/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(open("dd", O_CREATE) >= 0){
     printf(1, "create dd succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(open("dd", O_RDWR) >= 0){
     printf(1, "open dd rdwr succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(open("dd", O_WRONLY) >= 0){
     printf(1, "open dd wronly succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(link("dd/ff/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(link("dd/xx/ff", "dd/dd/xx") == 0){
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(link("dd/ff", "dd/dd/ffff") == 0){
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("dd/ff/ff") == 0){
     printf(1, "mkdir dd/ff/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("dd/xx/ff") == 0){
     printf(1, "mkdir dd/xx/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("dd/dd/ffff") == 0){
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd/xx/ff") == 0){
     printf(1, "unlink dd/xx/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd/ff/ff") == 0){
     printf(1, "unlink dd/ff/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("dd/ff") == 0){
     printf(1, "chdir dd/ff succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("dd/xx") == 0){
     printf(1, "chdir dd/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(unlink("dd/dd/ffff") != 0){
     printf(1, "unlink dd/dd/ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd/ff") != 0){
     printf(1, "unlink dd/ff failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd") == 0){
     printf(1, "unlink non-empty dd succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd/dd") < 0){
     printf(1, "unlink dd/dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dd") < 0){
     printf(1, "unlink dd failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   printf(1, "subdir ok\n");
@@ -1127,14 +1127,14 @@ bigwrite(void)
     fd = open("bigwrite", O_CREATE | O_RDWR);
     if(fd < 0){
       printf(1, "cannot create bigwrite\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     int i;
     for(i = 0; i < 2; i++){
       int cc = write(fd, buf, sz);
       if(cc != sz){
         printf(1, "write(%d) ret %d\n", sz, cc);
-        exit();
+        exit(EXIT_STATUS_DEFAULT);
       }
     }
     close(fd);
@@ -1155,13 +1155,13 @@ bigfile(void)
   fd = open("bigfile", O_CREATE | O_RDWR);
   if(fd < 0){
     printf(1, "cannot create bigfile");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   for(i = 0; i < 20; i++){
     memset(buf, i, 600);
     if(write(fd, buf, 600) != 600){
       printf(1, "write bigfile failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   close(fd);
@@ -1169,31 +1169,31 @@ bigfile(void)
   fd = open("bigfile", 0);
   if(fd < 0){
     printf(1, "cannot open bigfile\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   total = 0;
   for(i = 0; ; i++){
     cc = read(fd, buf, 300);
     if(cc < 0){
       printf(1, "read bigfile failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(cc == 0)
       break;
     if(cc != 300){
       printf(1, "short read bigfile\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(buf[0] != i/2 || buf[299] != i/2){
       printf(1, "read bigfile wrong data\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     total += cc;
   }
   close(fd);
   if(total != 20*600){
     printf(1, "read bigfile wrong total\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   unlink("bigfile");
 
@@ -1210,32 +1210,32 @@ fourteen(void)
 
   if(mkdir("12345678901234") != 0){
     printf(1, "mkdir 12345678901234 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("12345678901234/123456789012345") != 0){
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
   if(fd < 0){
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
   if(fd < 0){
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
   if(mkdir("12345678901234/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("123456789012345/12345678901234") == 0){
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   printf(1, "fourteen ok\n");
@@ -1247,35 +1247,35 @@ rmdot(void)
   printf(1, "rmdot test\n");
   if(mkdir("dots") != 0){
     printf(1, "mkdir dots failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("dots") != 0){
     printf(1, "chdir dots failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink(".") == 0){
     printf(1, "rm . worked!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("..") == 0){
     printf(1, "rm .. worked!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(chdir("/") != 0){
     printf(1, "chdir / failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dots/.") == 0){
     printf(1, "unlink dots/. worked!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dots/..") == 0){
     printf(1, "unlink dots/.. worked!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dots") != 0){
     printf(1, "unlink dots failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(1, "rmdot ok\n");
 }
@@ -1290,49 +1290,49 @@ dirfile(void)
   fd = open("dirfile", O_CREATE);
   if(fd < 0){
     printf(1, "create dirfile failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
   if(chdir("dirfile") == 0){
     printf(1, "chdir dirfile succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   fd = open("dirfile/xx", 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   fd = open("dirfile/xx", O_CREATE);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(mkdir("dirfile/xx") == 0){
     printf(1, "mkdir dirfile/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dirfile/xx") == 0){
     printf(1, "unlink dirfile/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(link("README", "dirfile/xx") == 0){
     printf(1, "link to dirfile/xx succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(unlink("dirfile") != 0){
     printf(1, "unlink dirfile failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   fd = open(".", O_RDWR);
   if(fd >= 0){
     printf(1, "open . for writing succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   fd = open(".", 0);
   if(write(fd, "x", 1) > 0){
     printf(1, "write . succeeded!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
 
@@ -1351,11 +1351,11 @@ iref(void)
   for(i = 0; i < 50 + 1; i++){
     if(mkdir("irefd") != 0){
       printf(1, "mkdir irefd failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(chdir("irefd") != 0){
       printf(1, "chdir irefd failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
 
     mkdir("");
@@ -1388,24 +1388,24 @@ forktest(void)
     if(pid < 0)
       break;
     if(pid == 0)
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
   }
   
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   
   for(; n > 0; n--){
-    if(wait() < 0){
+    if(wait(0) < 0){
       printf(1, "wait stopped early\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   
-  if(wait() != -1){
+  if(wait(0) != -1){
     printf(1, "wait got too many\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   
   printf(1, "fork test OK\n");
@@ -1428,7 +1428,7 @@ sbrktest(void)
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     *b = 1;
     a = b + 1;
@@ -1436,17 +1436,17 @@ sbrktest(void)
   pid = fork();
   if(pid < 0){
     printf(stdout, "sbrk test fork failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   c = sbrk(1);
   c = sbrk(1);
   if(c != a + 1){
     printf(stdout, "sbrk test failed post-fork\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(pid == 0)
-    exit();
-  wait();
+    exit(EXIT_STATUS_DEFAULT);
+  wait(0);
 
   // can one grow address space to something big?
 #define BIG (100*1024*1024)
@@ -1455,7 +1455,7 @@ sbrktest(void)
   p = sbrk(amt);
   if (p != a) { 
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   lastaddr = (char*) (BIG-1);
   *lastaddr = 99;
@@ -1465,12 +1465,12 @@ sbrktest(void)
   c = sbrk(-4096);
   if(c == (char*)0xffffffff){
     printf(stdout, "sbrk could not deallocate\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   c = sbrk(0);
   if(c != a - 4096){
     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   // can one re-allocate that page?
@@ -1478,19 +1478,19 @@ sbrktest(void)
   c = sbrk(4096);
   if(c != a || sbrk(0) != a + 4096){
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   if(*lastaddr == 99){
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
   if(c != a){
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   
   // can we read the kernel's memory?
@@ -1499,21 +1499,21 @@ sbrktest(void)
     pid = fork();
     if(pid < 0){
       printf(stdout, "fork failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
-    wait();
+    wait(0);
   }
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
   if(pipe(fds) != 0){
     printf(1, "pipe() failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if((pids[i] = fork()) == 0){
@@ -1533,11 +1533,11 @@ sbrktest(void)
     if(pids[i] == -1)
       continue;
     kill(pids[i]);
-    wait();
+    wait(0);
   }
   if(c == (char*)0xffffffff){
     printf(stdout, "failed sbrk leaked memory\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   if(sbrk(0) > oldbrk)
@@ -1572,17 +1572,17 @@ validatetest(void)
     if((pid = fork()) == 0){
       // try to crash the kernel by passing in a badly placed integer
       validateint((int*)p);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     sleep(0);
     sleep(0);
     kill(pid);
-    wait();
+    wait(0);
 
     // try to crash the kernel by passing in a bad string pointer
     if(link("nosuchfile", (char*)p) != -1){
       printf(stdout, "link should not succeed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
 
@@ -1600,7 +1600,7 @@ bsstest(void)
   for(i = 0; i < sizeof(uninit); i++){
     if(uninit[i] != '\0'){
       printf(stdout, "bss test failed\n");
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
   }
   printf(stdout, "bss test ok\n");
@@ -1627,16 +1627,16 @@ bigargtest(void)
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   } else if(pid < 0){
     printf(stdout, "bigargtest: fork failed\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
-  wait();
+  wait(0);
   fd = open("bigarg-ok", 0);
   if(fd < 0){
     printf(stdout, "bigarg test failed!\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(fd);
   unlink("bigarg-ok");
@@ -1710,7 +1710,7 @@ main(int argc, char *argv[])
 
   if(open("usertests.ran", 0) >= 0){
     printf(1, "already ran user tests -- rebuild fs.img\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   close(open("usertests.ran", O_CREATE));
 
@@ -1753,5 +1753,5 @@ main(int argc, char *argv[])
   bigdir(); // slow
   exectest();
 
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/usys.S b/usys.S
index 8bfd8a1..ad9ff4d 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,8 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(waitpid)
+SYSCALL(wait_stat)
+SYSCALL(list_pgroup)
+SYSCALL(foreground)
+SYSCALL(set_priority)
diff --git a/wc.c b/wc.c
index d6a54df..dc8042a 100644
--- a/wc.c
+++ b/wc.c
@@ -27,7 +27,7 @@ wc(int fd, char *name)
   }
   if(n < 0){
     printf(1, "wc: read error\n");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
   printf(1, "%d %d %d %s\n", l, w, c, name);
 }
@@ -39,16 +39,16 @@ main(int argc, char *argv[])
 
   if(argc <= 1){
     wc(0, "");
-    exit();
+    exit(EXIT_STATUS_DEFAULT);
   }
 
   for(i = 1; i < argc; i++){
     if((fd = open(argv[i], 0)) < 0){
       printf(1, "wc: cannot open %s\n", argv[i]);
-      exit();
+      exit(EXIT_STATUS_DEFAULT);
     }
     wc(fd, argv[i]);
     close(fd);
   }
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
diff --git a/zombie.c b/zombie.c
index 077c02c..a64409a 100644
--- a/zombie.c
+++ b/zombie.c
@@ -10,5 +10,5 @@ main(void)
 {
   if(fork() > 0)
     sleep(5);  // Let child exit before parent.
-  exit();
+  exit(EXIT_STATUS_DEFAULT);
 }
